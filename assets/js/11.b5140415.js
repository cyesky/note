(window.webpackJsonp=window.webpackJsonp||[]).push([[11],{266:function(t,e,a){"use strict";a.r(e);var s=a(38),r=Object(s.a)({},function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"web-前端面试总结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#web-前端面试总结","aria-hidden":"true"}},[t._v("#")]),t._v(" web 前端面试总结")]),t._v(" "),a("h2",{attrs:{id:"一、css-问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#一、css-问题","aria-hidden":"true"}},[t._v("#")]),t._v(" 一、CSS 问题")]),t._v(" "),a("h3",{attrs:{id:"_1-flex-布局"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-flex-布局","aria-hidden":"true"}},[t._v("#")]),t._v(" 1.flex 布局")]),t._v(" "),a("blockquote",[a("p",[t._v("display:flex; 在父元素设置，子元素受弹性盒影响，默认排成一行，如果超出一行，按比例压缩 flex:1; 子元素设置，设置子元素如何分配父元素的空间，flex:1,子元素宽度占满整个父元素 align-items:center 定义子元素在父容器中的对齐方式，center 垂直居中 justify-content:center 设置子元素在父元素中居中，前提是子元素没有把父元素占满，让子元素水平居中。")])]),t._v(" "),a("h3",{attrs:{id:"_2-css3-的新特性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-css3-的新特性","aria-hidden":"true"}},[t._v("#")]),t._v(" 2.css3 的新特性")]),t._v(" "),a("blockquote",[a("p",[t._v("transtion transition-property 规定设置过渡效果的 CSS 属性的名称。")])]),t._v(" "),a("blockquote",[a("p",[t._v("transition-duration 规定完成过渡效果需要多少秒或毫秒。")])]),t._v(" "),a("blockquote",[a("p",[t._v("transition-timing-function 规定速度效果的速度曲线。")])]),t._v(" "),a("blockquote",[a("p",[t._v("transition-delay 定义过渡效果何时开始。")])]),t._v(" "),a("blockquote",[a("p",[t._v("animation 属性可以像 Flash 制作动画一样，通过控制关键帧来控制动画的每一步，实现更为复杂的动画效果。")])]),t._v(" "),a("blockquote",[a("p",[t._v("ainimation 实现动画效果主要由两部分组成：")])]),t._v(" "),a("blockquote",[a("p",[t._v("通过类似 Flash 动画中的帧来声明一个动画；")])]),t._v(" "),a("blockquote",[a("p",[t._v("在 animation 属性中调用关键帧声明的动画。")])]),t._v(" "),a("blockquote",[a("p",[t._v("translate 3D 建模效果")])]),t._v(" "),a("h3",{attrs:{id:"_3-img-中-alt-和-title-的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-img-中-alt-和-title-的区别","aria-hidden":"true"}},[t._v("#")]),t._v(" 3.img 中 alt 和 title 的区别")]),t._v(" "),a("blockquote",[a("p",[t._v("图片中的 alt 属性是在图片不能正常显示时出现的文本提示。alt 有利于 SEO 优化")])]),t._v(" "),a("blockquote",[a("p",[t._v("图片中的 title 属性是在鼠标在移动到元素上的文本提示。")])]),t._v(" "),a("h3",{attrs:{id:"_4-用纯-css-创建一个三角形"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-用纯-css-创建一个三角形","aria-hidden":"true"}},[t._v("#")]),t._v(" 4.用纯 CSS 创建一个三角形")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v(" <style>\n    div {\n        width: 0;\n        height: 0;\n        border-top: 40px solid transparent;\n        border-left: 40px solid transparent;\n        border-right: 40px solid transparent;\n        border-bottom: 40px solid #ff0000;\n    }\n    </style>\n</head>\n<body>\n  <div></div>\n</body>\n复制代码\n")])])]),a("h3",{attrs:{id:"_5-如何理解-css-的盒子模型？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-如何理解-css-的盒子模型？","aria-hidden":"true"}},[t._v("#")]),t._v(" 5.如何理解 CSS 的盒子模型？")]),t._v(" "),a("blockquote",[a("p",[t._v("标准盒子模型：宽度=内容的宽度（content）+ border + padding")])]),t._v(" "),a("blockquote",[a("p",[t._v("低版本 IE 盒子模型：宽度=内容宽度（content+border+padding)")])]),t._v(" "),a("h3",{attrs:{id:"_6-如何让一个-div-水平居中"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-如何让一个-div-水平居中","aria-hidden":"true"}},[t._v("#")]),t._v(" 6.如何让一个 div 水平居中")]),t._v(" "),a("blockquote",[a("p",[t._v("已知宽度，block 元素 ，添加添加 margin:0 auto 属性。")])]),t._v(" "),a("blockquote",[a("p",[t._v("已知宽度，绝对定位的居中 ，上下左右都为 0，margin:auto")])]),t._v(" "),a("h3",{attrs:{id:"_7-如何让一个-div-水平垂直居中"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_7-如何让一个-div-水平垂直居中","aria-hidden":"true"}},[t._v("#")]),t._v(" 7.如何让一个 div 水平垂直居中")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("div {\nposition: relative / fixed; /* 相对定位或绝对定位均可 */\nwidth:500px;\nheight:300px;\ntop: 50%;\nleft: 50%;\nmargin-top:-150px;\nmargin-left:-250px;\n 外边距为自身宽高的一半 */\nbackground-color: pink; /* 方便看效果 */\n }\n\n.container {\ndisplay: flex;\nalign-items: center; /* 垂直居中 */\njustify-content: center; /* 水平居中 */\n\n}\n.container div {\nwidth: 100px; /* 可省 */\nheight: 100px; /* 可省 */\nbackground-color: pink; /* 方便看效果 */\n}\n复制代码\n")])])]),a("h3",{attrs:{id:"_8-如何清除浮动？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_8-如何清除浮动？","aria-hidden":"true"}},[t._v("#")]),t._v(" 8.如何清除浮动？")]),t._v(" "),a("blockquote",[a("p",[t._v("clear 清除浮动（添加空 div 法）在浮动元素下方添加空 div,并给该元素写 css 样式 {clear:both;height:0;overflow:hidden;}")])]),t._v(" "),a("blockquote",[a("p",[t._v("给浮动元素父级设置高度")])]),t._v(" "),a("blockquote",[a("p",[t._v("父级同时浮动（需要给父级同级元素添加浮动）")])]),t._v(" "),a("blockquote",[a("p",[t._v("父级设置成 inline-block，其 margin: 0 auto 居中方式失效")])]),t._v(" "),a("blockquote",[a("p",[t._v("给父级添加 overflow:hidden 清除浮动方法")])]),t._v(" "),a("blockquote",[a("p",[t._v("万能清除法 after 伪类 清浮动（现在主流方法，推荐使用）")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v('float_div:after{\ncontent:".";\nclear:both;\ndisplay:block;\nheight:0;\noverflow:hidden;\nvisibility:hidden;\n}\n.float_div{\nzoom:1\n}\n复制代码\n')])])]),a("h3",{attrs:{id:"_9-css3-实现三栏布局，左右固定，中间自适应"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_9-css3-实现三栏布局，左右固定，中间自适应","aria-hidden":"true"}},[t._v("#")]),t._v(" 9.css3 实现三栏布局，左右固定，中间自适应")]),t._v(" "),a("blockquote",[a("p",[t._v("圣杯布局/双飞翼布局")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v(" <style>\n        * {\n            margin: 0;\n            padding: 0;\n        }\n        .middle,\n        .left,\n        .right {\n            position: relative;\n            float: left;\n            min-height: 130px;\n        }\n        .container {\n            padding: 0 220px 0 200px;\n            overflow: hidden;\n        }\n        .left {\n            margin-left: -100%;\n            left: -200px;\n            width: 200px;\n            background: red;\n        }\n        .right {\n            margin-left: -220px;\n            right: -220px;\n            width: 220px;\n            background: green;\n        }\n        .middle {\n            width: 100%;\n            background: blue;\n            word-break: break-all;\n        }\n    </style>\n</head>\n<body>\n    <div class='container'>\n        <div class='middle'></div>\n        <div class='left'></div>\n        <div class='right'></div>\n    </div>\n</body>\n复制代码\n")])])]),a("h3",{attrs:{id:"_10-display-none-和-visibility-hidden-的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_10-display-none-和-visibility-hidden-的区别","aria-hidden":"true"}},[t._v("#")]),t._v(" 10.display:none 和 visibility: hidden 的区别")]),t._v(" "),a("blockquote",[a("p",[t._v("display:none 隐藏对应的元素，在文档布局中不再给它分配空间，它各边的元素会合拢，就当他从来不存在。")])]),t._v(" "),a("blockquote",[a("p",[t._v("visibility:hidden 隐藏对应的元素，但是在文档布局中仍保留原来的空间。")])]),t._v(" "),a("h3",{attrs:{id:"_11-css-中-link-和-import-的区别是？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_11-css-中-link-和-import-的区别是？","aria-hidden":"true"}},[t._v("#")]),t._v(" 11.CSS 中 link 和@import 的区别是？")]),t._v(" "),a("blockquote",[a("p",[t._v("link 属于 HTML 标签，而@import 是 CSS 提供的页面被加载的时，link 会同时被加载，而@import 引用的 CSS 会等到页面被加载完再加载")])]),t._v(" "),a("blockquote",[a("p",[t._v("import 只在 IE5 以上才能识别，而 link 是 HTML 标签，无兼容问题")])]),t._v(" "),a("blockquote",[a("p",[t._v("link 方式的样式的权重 高于@import 的权重.")])]),t._v(" "),a("h3",{attrs:{id:"_12-position-的-absolute-与-fixed-共同点与不同点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_12-position-的-absolute-与-fixed-共同点与不同点","aria-hidden":"true"}},[t._v("#")]),t._v(" 12.position 的 absolute 与 fixed 共同点与不同点")]),t._v(" "),a("blockquote",[a("p",[t._v("共同点： 改变行内元素的呈现方式，display 被置为 block 让元素脱离普通流，不占据空间 默认会覆盖到非定位元素上")])]),t._v(" "),a("blockquote",[a("p",[t._v("不同点： absolute 的”根元素“是可以设置的 fixed 的”根元素“固定为浏览器窗口。当你滚动网页，fixed 元素与浏览器窗口之间的距离是不变的。")])]),t._v(" "),a("h3",{attrs:{id:"_13-transition-和-animation-的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_13-transition-和-animation-的区别","aria-hidden":"true"}},[t._v("#")]),t._v(" 13..transition 和 animation 的区别")]),t._v(" "),a("blockquote",[a("p",[t._v("Animation 和 transition 大部分属性是相同的，他们都是随时间改变元素的属性值，他们的主要区别是 transition 需要触发一个事件才能改变属性， 而 animation 不需要触发任何事件的情况下才会随时间改变属性值，并且 transition 为 2 帧，从 from .... to，而 animation 可以一帧一帧的。")])]),t._v(" "),a("blockquote",[a("p",[t._v("transition 规定动画的名字 规定完成过渡效果需要多少秒或毫秒 规定速度效果 定义过渡效果何时开始 animation 指定要绑定到选择器的关键帧的名称")])]),t._v(" "),a("h3",{attrs:{id:"_14-css-优先级"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_14-css-优先级","aria-hidden":"true"}},[t._v("#")]),t._v(" 14.CSS 优先级")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("不同级别：总结排序：!important > 行内样式>ID选择器 > 类选择器 > 标签 > 通配符 > 继承 > 浏览器默认属性\n\t1.属性后面加!import 会覆盖页面内任何位置定义的元素样式\n\t2.作为style属性写在元素内的样式\n\t3.id选择器\n\t4.类选择器\n\t5.标签选择器\n\t6.通配符选择器（*）\n\t7.浏览器自定义或继承\n**同一级别：后写的会覆盖先写的**\n复制代码\n")])])]),a("blockquote",[a("p",[t._v("css 选择器的解析原则：选择器定位 DOM 元素是从右往左的方向，这样可以尽早的过滤掉一些不必要的样式规则和元素")])]),t._v(" "),a("h3",{attrs:{id:"_15-雪碧图："}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_15-雪碧图：","aria-hidden":"true"}},[t._v("#")]),t._v(" 15.雪碧图：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("        多个图片集成在一个图片中的图\n\t使用雪碧图可以减少网络请求的次数，加快允许的速度\n\t通过background-position，去定位图片在屏幕的哪个位置\n复制代码\n")])])]),a("h2",{attrs:{id:"二、js-问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#二、js-问题","aria-hidden":"true"}},[t._v("#")]),t._v(" 二、JS 问题")]),t._v(" "),a("h3",{attrs:{id:"_1-typeof-和-instance-of-检测数据类型有什么区别？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-typeof-和-instance-of-检测数据类型有什么区别？","aria-hidden":"true"}},[t._v("#")]),t._v(" 1.typeof 和 instance of 检测数据类型有什么区别？")]),t._v(" "),a("blockquote",[a("p",[t._v("相同点： 都常用来判断一个变量是否为空，或者是什么类型的。")])]),t._v(" "),a("blockquote",[a("p",[t._v("不同点： typeof 返回值是一个字符串，用来说明变量的数据类型 instanceof 用于判断一个变量是否属于某个对象的实例.")])]),t._v(" "),a("h3",{attrs:{id:"_16-使元素消失的方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_16-使元素消失的方法","aria-hidden":"true"}},[t._v("#")]),t._v(" 16.使元素消失的方法")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("visibility:hidden、display:none、z-index=-1、opacity：0\n1.opacity：0,该元素隐藏起来了，但不会改变页面布局，并且，如果该元素已经绑定了一些事件，如click事件也能触发\n2.visibility:hidden,该元素隐藏起来了，但不会改变页面布局，但是不会触发该元素已经绑定的事件\n3.display:node, 把元素隐藏起来，并且会改变页面布局，可以理解成在页面中把该元素删掉\n复制代码\n")])])]),a("h3",{attrs:{id:"谈一谈深克隆和浅克隆？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#谈一谈深克隆和浅克隆？","aria-hidden":"true"}},[t._v("#")]),t._v(" .谈一谈深克隆和浅克隆？")]),t._v(" "),a("blockquote",[a("p",[t._v("浅克隆: 只是拷贝了基本类型的数据，而引用类型数据，复制后也是会发生引用，我们把这种拷贝叫做“（浅复制）浅拷贝”，换句话说，浅复制仅仅是指向被复制的内存地址，如果原地址中对象被改变了，那么浅复制出来的对象也会相应改变。")])]),t._v(" "),a("blockquote",[a("p",[t._v("深克隆： 创建一个新对象，属性中引用的其他对象也会被克隆，不再指向原有对象地址。 JSON.parse、JSON.stringify()")])]),t._v(" "),a("h3",{attrs:{id:"_3-es6-的新特性都有哪些？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-es6-的新特性都有哪些？","aria-hidden":"true"}},[t._v("#")]),t._v(" 3.es6 的新特性都有哪些？")]),t._v(" "),a("blockquote",[a("p",[t._v("let 定义块级作用域变量 没有变量的提升，必须先声明后使用 let 声明的变量，不能与前面的 let，var，conset 声明的变量重名")])]),t._v(" "),a("blockquote",[a("p",[t._v("const 定义只读变量 const 声明变量的同时必须赋值，const 声明的变量必须初始化，一旦初始化完毕就不允许修改 const 声明变量也是一个块级作用域变量 const 声明的变量没有“变量的提升”，必须先声明后使用 const 声明的变量不能与前面的 let， var ， const 声明的变量重 const 定义的对象\\数组中的属性值可以修改,基础数据类型不可以")])]),t._v(" "),a("blockquote",[a("p",[t._v("ES6 可以给形参函数设置默认值")])]),t._v(" "),a("blockquote",[a("p",[t._v("在数组之前加上三个点（...）展开运算符")])]),t._v(" "),a("blockquote",[a("p",[t._v("数组的解构赋值、对象的解构赋值")])]),t._v(" "),a("blockquote",[a("p",[t._v("箭头函数的特点 箭头函数相当于匿名函数，是不能作为构造函数的，不能被 new 箭头函数没有 arguments 实参集合,取而代之用...剩余运算符解决 箭头函数没有自己的 this。他的 this 是继承当前上下文中的 this 箭头函数没有函数原型 箭头函数不能当做 Generator 函数，不能使用 yield 关键字 不能使用 call、apply、bind 改变箭头函数中 this 指向 Set 数据结构，数组去重")])]),t._v(" "),a("h3",{attrs:{id:"_4-和-区别是什么？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-和-区别是什么？","aria-hidden":"true"}},[t._v("#")]),t._v(" 4.==和===区别是什么？")]),t._v(" "),a("blockquote",[a("p",[t._v("=赋值")])]),t._v(" "),a("blockquote",[a("p",[t._v("==返回一个布尔值；相等返回 true，不相等返回 false； 允许不同数据类型之间的比较； 如果是不同类型的数据进行，会默认进行数据类型之间的转换； 如果是对象数据类型的比较，比较的是空间地址")])]),t._v(" "),a("blockquote",[a("p",[t._v("=== 只要数据类型不一样，就返回 false；")])]),t._v(" "),a("h3",{attrs:{id:"_5-常见的设计模式有哪些？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-常见的设计模式有哪些？","aria-hidden":"true"}},[t._v("#")]),t._v(" 5.常见的设计模式有哪些？")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("1、js工厂模式\n2、js构造函数模式\n3、js原型模式\n4、构造函数+原型的js混合模式\n5、构造函数+原型的动态原型模式\n6、观察者模式\n7、发布订阅模式\n复制代码\n")])])]),a("h3",{attrs:{id:"_6-call-bind-apply-的区别？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-call-bind-apply-的区别？","aria-hidden":"true"}},[t._v("#")]),t._v(" 6.call bind apply 的区别？")]),t._v(" "),a("blockquote",[a("p",[t._v("call() 和 apply()的第一个参数相同，就是指定的对象。这个对象就是该函数的执行上下文。")])]),t._v(" "),a("blockquote",[a("p",[t._v("call()和 apply()的区别就在于，两者之间的参数。")])]),t._v(" "),a("blockquote",[a("p",[t._v("call()在第一个参数之后的 后续所有参数就是传入该函数的值。")])]),t._v(" "),a("blockquote",[a("p",[t._v("apply() 只有两个参数，第一个是对象，第二个是数组，这个数组就是该函数的参数。 bind() 方法和前两者不同在于： bind() 方法会返回执行上下文被改变的函数而不会立即执行，而前两者是 直接执行该函数。他的参数和 call()相同。")])]),t._v(" "),a("h3",{attrs:{id:"_7-js-继承方式有哪些？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_7-js-继承方式有哪些？","aria-hidden":"true"}},[t._v("#")]),t._v(" 7.js 继承方式有哪些？")]),t._v(" "),a("blockquote",[a("p",[t._v("原型链继承 核心： 将父类的实例作为子类的原型")])]),t._v(" "),a("blockquote",[a("p",[t._v("构造继承 核心：使用父类的构造函数来增强子类实例，等于是复制父类的实例属性给子类")])]),t._v(" "),a("blockquote",[a("p",[t._v("实例继承 核心：为父类实例添加新特性，作为子类实例返回")])]),t._v(" "),a("blockquote",[a("p",[t._v("拷贝继承")])]),t._v(" "),a("blockquote",[a("p",[t._v("组合继承 核心：通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现 函数复用")])]),t._v(" "),a("blockquote",[a("p",[t._v("寄生组合继承 核心：通过寄生方式，砍掉父类的实例属性，这样，在调用两次父类的构造的时候，就不会初始化两次实 例方法/属性，避免的组合继承的缺点")])]),t._v(" "),a("h3",{attrs:{id:"_8-你怎样看待闭包？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_8-你怎样看待闭包？","aria-hidden":"true"}},[t._v("#")]),t._v(" 8.你怎样看待闭包？")]),t._v(" "),a("blockquote",[a("p",[t._v("个人感觉，简单来说闭包就是在函数里面声明函数，本质上说就是在函数内部和函数外部搭建起一座桥梁，使得子函数可以访问父函数中所有的局部变量，但是反之不可以，这只是闭包的作用之一，另一个作用，则是保护变量不受外界污染，使其一直存在内存中，在工作中我们还是少使用闭包的好，因为闭包太消耗内存，不到万不得已的时候尽量不使用。")])]),t._v(" "),a("h3",{attrs:{id:"_9-你是如何理解原型和原型链的？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_9-你是如何理解原型和原型链的？","aria-hidden":"true"}},[t._v("#")]),t._v(" 9.你是如何理解原型和原型链的？")]),t._v(" "),a("blockquote",[a("p",[t._v("把所有的对象共用的属性全部放在堆内存的一个对象（共用属性组成的对象），然后让每一个对象的 "),a("strong",[t._v("proto")]),t._v("存储这个「共用属性组成的对象」的地址。而这个共用属性就是原型，原型出现的目的就是为了减少不必要的内存消耗。而原型链就是对象通过"),a("strong",[t._v("proto")]),t._v("向当前实例所属类的原型上查找属性或方法的机制，如果找到 Object 的原型上还是没有找到想要的属性或者是方法则查找结束，最终会返回 undefined")])]),t._v(" "),a("h3",{attrs:{id:"_10-浏览器渲染的主要流程是什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_10-浏览器渲染的主要流程是什么","aria-hidden":"true"}},[t._v("#")]),t._v(" 10.浏览器渲染的主要流程是什么?")]),t._v(" "),a("blockquote",[a("p",[t._v("将 html 代码按照深度优先遍历来生成 DOM 树。 css 文件下载完后也会进行渲染，生成相应的 CSSOM。 当所有的 css 文件下载完且所有的 CSSOM 构建结束后，就会和 DOM 一起生成 Render Tree。 接下来，浏览器就会进入 Layout 环节，将所有的节点位置计算出来。 最后，通过 Painting 环节将所有的节点内容呈现到屏幕上。")])]),t._v(" "),a("h3",{attrs:{id:"_11-从输入-url-地址到页面相应都发生了什么？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_11-从输入-url-地址到页面相应都发生了什么？","aria-hidden":"true"}},[t._v("#")]),t._v(" 11.从输入 url 地址到页面相应都发生了什么？")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("1、浏览器的地址栏输入URL并按下回车。\n2、浏览器查找当前URL是否存在缓存，并比较缓存是否过期。3、DNS解析URL对应的IP。\n4、根据IP建立TCP连接（三次握手）。\n5、HTTP发起请求。\n6、服务器处理请求，浏览器接收HTTP响应。\n7、渲染页面，构建DOM树。\n8、关闭TCP连接（四次挥手）\n复制代码\n")])])]),a("h3",{attrs:{id:"_12-session、cookie、localstorage-的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_12-session、cookie、localstorage-的区别","aria-hidden":"true"}},[t._v("#")]),t._v(" 12.session、cookie、localStorage 的区别")]),t._v(" "),a("blockquote",[a("p",[t._v("相同点 都是保存在浏览器端，且同源的。")])]),t._v(" "),a("blockquote",[a("p",[t._v("不同点")])]),t._v(" "),a("ul",[a("li",[t._v("cookie 数据始终在同源的 http 请求中携带，即 cookie 在浏览器和服务器间来回传递。")]),t._v(" "),a("li",[t._v("而 sessionStorage 和 localStorage 不会自动把数据发给服务器，仅在本地保存。")]),t._v(" "),a("li",[t._v("cookie 数据还有路径（path）的概念，可以限制 cookie 只属于某个路径下。 存储大小限制也不同，cookie 数据不能超过 4k，同时因为每次 http 请求都会携带 cookie，所以 cookie 只适合保存很小的数据。")]),t._v(" "),a("li",[t._v("sessionStorage 和 localStorage 虽然也有存储大小的限制，但比 cookie 大得多，可以达到 5M 或更大。 数据有效期不同，sessionStorage：仅在当前浏览器窗口关闭前有效，自然也就不可能持久保持；")]),t._v(" "),a("li",[t._v("localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；")]),t._v(" "),a("li",[t._v("cookie 只在设置的 cookie 过期时间之前一直有效，即使窗口或浏览器关闭。 作用域不同，sessionStorage 不在不同的浏览器窗口中共享，即使是同一个页面；")]),t._v(" "),a("li",[t._v("localStorage 在所有同源窗口中都是共享的；cookie 也是在所有同源窗口中都是共享的。")])]),t._v(" "),a("h3",{attrs:{id:"_13-js-中跨域方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_13-js-中跨域方法","aria-hidden":"true"}},[t._v("#")]),t._v(" 13.js 中跨域方法")]),t._v(" "),a("blockquote",[a("p",[t._v("同源策略（协议+端口号+域名要相同）")])]),t._v(" "),a("blockquote",[a("p",[t._v("1、jsonp 跨域(只能解决 get） 原理：动态创建一个 script 标签。利用 script 标签的 src 属性不受同源策略限制，因为所有的 src 属性和 href 属性都不受同源策略的限制，可以请求第三方服务器资源内容")]),t._v(" "),a("blockquote",[a("p",[t._v("步骤： 1).去创建一个 script 标签 2).script 的 src 属性设置接口地址 3).接口参数，必须要带一个自定义函数名，要不然后台无法返回数据 4).通过定义函数名去接受返回的数据")])])]),t._v(" "),a("blockquote",[a("p",[t._v("2、document.domain 基础域名相同 子域名不同")])]),t._v(" "),a("blockquote",[a("p",[t._v("3、window.name 利用在一个浏览器窗口内，载入所有的域名都是共享一个 window.name")])]),t._v(" "),a("blockquote",[a("p",[t._v("4、服务器设置对 CORS 的支持 原理：服务器设置 Access-Control-Allow-Origin HTTP 响应头之后，浏览器将会允许跨域请求")])]),t._v(" "),a("blockquote",[a("p",[t._v("5、利用 h5 新特性 window.postMessage()")])]),t._v(" "),a("h3",{attrs:{id:"_14-前端有哪些页面优化方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_14-前端有哪些页面优化方法","aria-hidden":"true"}},[t._v("#")]),t._v(" 14.前端有哪些页面优化方法?")]),t._v(" "),a("ul",[a("li",[t._v("减少 HTTP 请求数")]),t._v(" "),a("li",[t._v("从设计实现层面简化页面")]),t._v(" "),a("li",[t._v("合理设置 HTTP 缓存")]),t._v(" "),a("li",[t._v("资源合并与压缩")]),t._v(" "),a("li",[t._v("合并 CSS 图片，减少请求数的又一个好办法。")]),t._v(" "),a("li",[t._v("将外部脚本置底（将脚本内容在页面信息内容加载后再加载）")]),t._v(" "),a("li",[t._v("多图片网页使用图片懒加载。")]),t._v(" "),a("li",[t._v("在 js 中尽量减少闭包的使用")]),t._v(" "),a("li",[t._v("尽量合并 css 和 js 文件")]),t._v(" "),a("li",[t._v("尽量使用字体图标或者 SVG 图标，来代替传统的 PNG 等格式的图片")]),t._v(" "),a("li",[t._v("减少对 DOM 的操作")]),t._v(" "),a("li",[t._v("在 JS 中避免“嵌套循环”和 “死循环”")]),t._v(" "),a("li",[t._v("尽可能使用事件委托（事件代理）来处理事件绑定的操作")])]),t._v(" "),a("h3",{attrs:{id:"_15-ajax-的四个步骤"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_15-ajax-的四个步骤","aria-hidden":"true"}},[t._v("#")]),t._v(" 15.Ajax 的四个步骤")]),t._v(" "),a("blockquote",[a("p",[t._v("1.创建 ajax 实例")])]),t._v(" "),a("blockquote",[a("p",[t._v("2.执行 open 确定要访问的链接 以及同步异步")])]),t._v(" "),a("blockquote",[a("p",[t._v("3.监听请求状态")])]),t._v(" "),a("blockquote",[a("p",[t._v("4.发送请求")])]),t._v(" "),a("h3",{attrs:{id:"_16-数组去重的方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_16-数组去重的方法","aria-hidden":"true"}},[t._v("#")]),t._v(" 16.数组去重的方法")]),t._v(" "),a("blockquote",[a("p",[t._v("ES6 的 set 对象 先将原数组排序，在与相邻的进行比较，如果不同则存入新数组")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("function unique(arr){\n    var arr2 = arr.sort();\n    var res = [arr2[0]];\n    for(var i=1;i<arr2.length;i++){\n        if(arr2[i] !== res[res.length-1]){\n        res.push(arr2[i]);\n    }\n}\nreturn res;\n}\n利用下标查询\n function unique(arr){\n    var newArr = [arr[0]];\n    for(var i=1;i<arr.length;i++){\n        if(newArr.indexOf(arr[i]) == -1){\n        newArr.push(arr[i]);\n    }\n}\nreturn newArr;\n}\n复制代码\n")])])]),a("h3",{attrs:{id:"_17-ajax-中-get-和-post-请求的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_17-ajax-中-get-和-post-请求的区别","aria-hidden":"true"}},[t._v("#")]),t._v(" 17.ajax 中 get 和 post 请求的区别")]),t._v(" "),a("ul",[a("li",[t._v("get 一般用于获取数据")]),t._v(" "),a("li",[t._v("get 请求如果需要传递参数，那么会默认将参数拼接到 url 的后面；然后发送给服务器；")]),t._v(" "),a("li",[t._v("get 请求传递参数大小是有限制的；是浏览器的地址栏有大小限制；")]),t._v(" "),a("li",[t._v("get 安全性较低")]),t._v(" "),a("li",[t._v("get 一般会走缓存，为了防止走缓存，给 url 后面每次拼的参数不同；放在?后面，一般用个时间戳")]),t._v(" "),a("li",[t._v("post 一般用于发送数据")]),t._v(" "),a("li",[t._v("post 传递参数，需要把参数放进请求体中，发送给服务器；")]),t._v(" "),a("li",[t._v("post 请求参数放进了请求体中，对大小没有要求；")]),t._v(" "),a("li",[t._v("post 安全性比较高；")]),t._v(" "),a("li",[t._v("post 请求不会走缓存；")]),t._v(" "),a("li")]),t._v(" "),a("h3",{attrs:{id:"_18-ajax-的状态码"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_18-ajax-的状态码","aria-hidden":"true"}},[t._v("#")]),t._v(" 18.ajax 的状态码")]),t._v(" "),a("blockquote",[a("p",[t._v("2 开头")])]),t._v(" "),a("ul",[a("li",[t._v("200 : 代表请求成功；")])]),t._v(" "),a("blockquote",[a("p",[t._v("3 开头")])]),t._v(" "),a("ul",[a("li",[t._v("301 : 永久重定向；")]),t._v(" "),a("li",[t._v("302: 临时转移")]),t._v(" "),a("li",[t._v("304 : 读取缓存 [表示浏览器端有缓存，并且服务端未更新，不再向服务端请求资源]")]),t._v(" "),a("li",[t._v("307:临时重定向")])]),t._v(" "),a("blockquote",[a("p",[t._v("以 4 开头的都是客户端的问题；")])]),t._v(" "),a("ul",[a("li",[t._v("400 :数据/格式错误")]),t._v(" "),a("li",[t._v("401: 权限不够；（身份不合格，访问网站的时候，登录和不登录是不一样的）")]),t._v(" "),a("li",[t._v("404 : 路径错误，找不到文件")])]),t._v(" "),a("blockquote",[a("p",[t._v("以 5 开头都是服务端的问题")])]),t._v(" "),a("ul",[a("li",[t._v("500 : 服务器的问题")]),t._v(" "),a("li",[t._v("503: 超负荷；")])]),t._v(" "),a("h3",{attrs:{id:"_19-移动端的兼容问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_19-移动端的兼容问题","aria-hidden":"true"}},[t._v("#")]),t._v(" 19.移动端的兼容问题")]),t._v(" "),a("ul",[a("li",[a("p",[t._v("给移动端添加点击事件会有 300S 的延迟 如果用点击事件，需要引一个 fastclick.js 文件，解决 300s 的延迟 一般在移动端用 ontouchstart、ontouchmove、ontouchend")])]),t._v(" "),a("li",[a("p",[t._v("移动端点透问题,touchstart 早于 touchend 早于 click,click 的触发是有延迟的，这个时间大概在 300ms 左右，也就是说我们 tap 触发之后蒙层隐藏， 此时 click 还没有触发，300ms 之后由于蒙层隐藏，我们的 click 触发到了下面的 a 链接上 尽量都使用 touch 事件来替换 click 事件。例如用 touchend 事件(推荐)。 用 fastclick，"),a("a",{attrs:{href:"https://github.com/ftlabs/fastclick",target:"_blank",rel:"noopener noreferrer"}},[t._v("github.com/ftlabs/fast…"),a("OutboundLink")],1),t._v(" 用 preventDefault 阻止 a 标签的 click 消除 IE10 里面的那个叉号 input:-ms-clear{display:none;}")])]),t._v(" "),a("li",[a("p",[t._v("设置缓存 手机页面通常在第一次加载后会进行缓存，然后每次刷新会使用缓存而不是去重新向服务器发送请求。如果不希望使用缓存可以设置 no-cache。")])]),t._v(" "),a("li",[a("p",[t._v("圆角 BUG 某些 Android 手机圆角失效 background-clip: padding-box; 防止手机中网页放大和缩小 这点是最基本的，做为手机网站开发者来说应该都知道的，就是设置 meta 中的 viewport")])]),t._v(" "),a("li",[a("p",[t._v("设置用户截止缩放，一般写视口的时候就已经写好了。")])]),t._v(" "),a("li")]),t._v(" "),a("h3",{attrs:{id:"_20-js-中同步和异步-以及-js-的事件流"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_20-js-中同步和异步-以及-js-的事件流","aria-hidden":"true"}},[t._v("#")]),t._v(" 20.JS 中同步和异步,以及 js 的事件流")]),t._v(" "),a("blockquote",[a("p",[t._v("同步：在同一时间内做一件事情")])]),t._v(" "),a("blockquote",[a("p",[t._v("异步：在同一时间内做多个事情 JS 是单线程的，每次只能做一件事情，JS 运行在浏览器中，浏览器是多线程的，可以在同一时间执行多个任务。")])]),t._v(" "),a("h3",{attrs:{id:"_21-js-中常见的异步任务"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_21-js-中常见的异步任务","aria-hidden":"true"}},[t._v("#")]),t._v(" 21.JS 中常见的异步任务")]),t._v(" "),a("blockquote",[a("p",[t._v("定时器、ajax、事件绑定、回调函数、async await、promise")])]),t._v(" "),a("h3",{attrs:{id:"_22-tcp-的三次握手和四次挥手"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_22-tcp-的三次握手和四次挥手","aria-hidden":"true"}},[t._v("#")]),t._v(" 22.TCP 的三次握手和四次挥手")]),t._v(" "),a("blockquote",[a("p",[t._v("三次握手")])]),t._v(" "),a("ul",[a("li",[t._v("第一次握手：客户端发送一个 SYN 码给服务器，要求建立数据连接；")]),t._v(" "),a("li",[t._v("第二次握手： 服务器 SYN 和自己处理一个 SYN（标志）；叫 SYN+ACK（确认包）；发送给客户端，可以建立连接")]),t._v(" "),a("li",[t._v("第三次握手： 客户端再次发送 ACK 向服务器，服务器验证 ACK 没有问题，则建立起连接；")])]),t._v(" "),a("blockquote",[a("p",[t._v("四次挥手")])]),t._v(" "),a("ul",[a("li",[t._v("第一次挥手： 客户端发送 FIN(结束)报文，通知服务器数据已经传输完毕；")]),t._v(" "),a("li",[t._v("第二次挥手: 服务器接收到之后，通知客户端我收到了 SYN,发送 ACK(确认)给客户端，数据还没有传输完成")]),t._v(" "),a("li",[t._v("第三次挥手： 服务器已经传输完毕，再次发送 FIN 通知客户端，数据已经传输完毕")]),t._v(" "),a("li",[t._v("第四次挥手： 客户端再次发送 ACK,进入 TIME_WAIT 状态；服务器和客户端关闭连接；")])]),t._v(" "),a("h3",{attrs:{id:"_23-为什么建立连接是三次握手，而断开连接是四次挥手呢"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_23-为什么建立连接是三次握手，而断开连接是四次挥手呢","aria-hidden":"true"}},[t._v("#")]),t._v(" 23.为什么建立连接是三次握手，而断开连接是四次挥手呢?")]),t._v(" "),a("blockquote",[a("blockquote",[a("p",[t._v("建立连接的时候， 服务器在 LISTEN 状态下，收到建立连接请求的 SYN 报文后，把 ACK 和 SYN 放在一个报文里发送给客户端。 而关闭连接时，服务器收到对方的 FIN 报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送 FIN 报文给对方来表示同意现在关闭连接，因此，己方 ACK 和 FIN 一般都会分开发送，从而导致多了一次。")])])]),t._v(" "),a("h3",{attrs:{id:"_24-dom-diff-原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_24-dom-diff-原理","aria-hidden":"true"}},[t._v("#")]),t._v(" 24.DOM diff 原理")]),t._v(" "),a("blockquote",[a("ul",[a("li",[t._v("如果元素类型发生变化，直接替换")]),t._v(" "),a("li",[t._v("如果是文本，则比较文本里面的内容，是否有差异，如果是元素就需要比较当前元素的属性是否相等,会先比较 key， 在比较类型 为什么 react 中循环 建议不要使用索引 ,如果纯为了展示 那可以使用索引")])])]),t._v(" "),a("h3",{attrs:{id:"_25-作用域"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_25-作用域","aria-hidden":"true"}},[t._v("#")]),t._v(" 25.作用域")]),t._v(" "),a("blockquote",[a("p",[t._v("全局作用域")])]),t._v(" "),a("ul",[a("li",[t._v("浏览器打开一个页面时，浏览器会给 JS 代码提供一个全局的运行环境，那么这个环境就是全局作用域 一个页面只有一个全局作用域，全局作用域下有一个 window 对象 window 是全局作用域下的最大的一个内置对象（全局作用域下定义的变量和函数都会存储在 window 下） 如果是全局变量，都会给 window 新增一个键值对；属性名就是变量名，属性值就是变量所存储的值 如果变量只被 var 过，那么存储值是 undefined 在私有作用域中是可以获取到全局变量的，但是在全局作用域中不能获取私有变量")])]),t._v(" "),a("blockquote",[a("p",[t._v("私有作用域")])]),t._v(" "),a("ul",[a("li",[t._v("函数执行会形成一个新的私有的作用域（执行多次，形成多个私有作用域） 私有作用域在全局作用域中形成，具有包含的关系； 在一个全局作用域中，可以有很多个私有作用域 在私有作用域下定义的变量都是私有变量 形参也是私有变量 函数体中通过 function 定义的函数也是私有的，在全局作用域不能使用；")])]),t._v(" "),a("blockquote",[a("p",[t._v("块级作用域")])]),t._v(" "),a("ul",[a("li",[t._v("es6 中新引入的一种作用域 在 js 中常见到的 if{}、for{}、while{}、try{}、catch{}、switch case{}都是块级作用域 var obj = {} //对象的大括号不是块级作用域 块级作用域中的同一变量不能被重复声明（块级下 var 和 function 不能重名，否则会报错） 作用域链")])]),t._v(" "),a("blockquote",[a("p",[t._v("上级作用域")])]),t._v(" "),a("ul",[a("li",[t._v("函数在哪里定义，他的上一级作用域就是哪，和函数在哪个作用域下执行没有关系 作用域链：当获取变量所对应的值时，首先看变量是否是私有变量，如果不是私有变量，要继续向上一级作用域中查找，如果上一级也没有，那么会继续向上一级查找，直到找到全局作用域为止；如果全局作用域也没有，则会报错；这样一级一级向上查找，就会形成作用域链 当前作用域没有的，则会继续向上一级作用域查找 当前函数的上一级作用域跟函数在哪个作用域下执行没有关系，只跟函数在哪定义有关（重点）")])]),t._v(" "),a("h3",{attrs:{id:"_26-promise-处理异步"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_26-promise-处理异步","aria-hidden":"true"}},[t._v("#")]),t._v(" 26.Promise 处理异步")]),t._v(" "),a("blockquote",[a("p",[t._v("他是 ES6 中新增加的一个类（new Promise）,目的是为了管理 JS 中的异步编程的，所以把他称为“Promise 设计模式” new Promise 经历三个状态：padding(准备状态：初始化成功、开始执行异步的任务)、fullfilled(成功状态)、rejected(失败状态)== Promise 本身是同步编程的，他可以管理异步操作的（重点），new Promise 的时候，会把传递的函数立即执行 Promise 函数天生有两个参数，resolve(当异步操作执行成功，执行 resolve 方法),rejected(当异步操作失败，执行 reject 方法) then()方法中有两个函数，第一个传递的函数是 resolve,第二个传递的函数是 reject ajax 中 false 代表同步，true 代表异步，如果使用异步，不等 ajax 彻底完成")])]),t._v(" "),a("h3",{attrs:{id:"_27-map-和-foreach-的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_27-map-和-foreach-的区别","aria-hidden":"true"}},[t._v("#")]),t._v(" 27.map 和 forEach 的区别")]),t._v(" "),a("blockquote",[a("p",[t._v("相同点")])]),t._v(" "),a("ul",[a("li",[t._v("都是循环遍历数组中的每一项 forEach 和 map 方法里每次执行匿名函数都支持 3 个参数，参数分别是 item（当前每一项）、index（索引值）、arr（原数组），需要用哪个的时候就写哪个 匿名函数中的 this 都是指向 window 只能遍历数组")])]),t._v(" "),a("blockquote",[a("p",[t._v("不同点")])]),t._v(" "),a("ul",[a("li",[t._v("map 方法返回一个新的数组，数组中的元素为原始数组调用函数处理后的值。(原数组进行处理之后对应的一个新的数组。) map()方法不会改变原始数组 map()方法不会对空数组进行检测 forEach()方法用于调用数组的每个元素，将元素传给回调函数.(没有 return，返回值是 undefined）")])]),t._v(" "),a("blockquote",[a("blockquote",[a("p",[a("strong",[t._v("注意")]),t._v("：forEach 对于空数组是不会调用回调函数的。")])])]),t._v(" "),a("h3",{attrs:{id:"_28-async-await-函数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_28-async-await-函数","aria-hidden":"true"}},[t._v("#")]),t._v(" 28.async await 函数")]),t._v(" "),a("blockquote",[a("p",[t._v("async/await 函数是异步代码的新方式")])]),t._v(" "),a("blockquote",[a("p",[t._v("async/await 是基于 promise 实现的")])]),t._v(" "),a("blockquote",[a("p",[t._v("async/await 使异步代码更像同步代码")])]),t._v(" "),a("blockquote",[a("p",[t._v("await 只能在 async 函数中使用，不能再普通函数中使用，要成对出现")])]),t._v(" "),a("blockquote",[a("p",[t._v("默认返回一个 promise 实例，不能被改变")])]),t._v(" "),a("blockquote",[a("p",[t._v("await 下面的代码是异步，后面的代码是同步的")])]),t._v(" "),a("h3",{attrs:{id:"_29-this-指向"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_29-this-指向","aria-hidden":"true"}},[t._v("#")]),t._v(" 29.this 指向")]),t._v(" "),a("blockquote",[a("ul",[a("li",[t._v("全局作用域下的 this 指向 window")]),t._v(" "),a("li",[t._v("如果给元素的事件行为绑定函数，那么函数中的 this 指向当前被绑定的那个元素")]),t._v(" "),a("li",[t._v("函数中的 this，要看函数执行前有没有 . , 有 . 的话，点前面是谁，this 就指向谁，如果没有点，指向 window")]),t._v(" "),a("li",[t._v("自执行函数中的 this 永远指向 window")]),t._v(" "),a("li",[t._v("定时器中函数的 this 指向 window")]),t._v(" "),a("li",[t._v("构造函数中的 this 指向当前的实例")]),t._v(" "),a("li",[t._v("call、apply、bind 可以改变函数的 this 指向")]),t._v(" "),a("li",[t._v("箭头函数中没有 this，如果输出 this，就会输出箭头函数定义时所在的作用域中的 this")])])]),t._v(" "),a("h3",{attrs:{id:"_30-原型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_30-原型","aria-hidden":"true"}},[t._v("#")]),t._v(" 30.原型")]),t._v(" "),a("blockquote",[a("blockquote",[a("p",[t._v("所有的函数数据类型都天生自带一个 prototype 属性，该属性的属性值是一个对象 prototype 的属性值中天生自带一个 constructor 属性，其 constructor 属性值指向当前原型所属的类 所有的对象数据类型，都天生自带一个"),a("em",[t._v("proto")]),t._v("属性，该属性的属性值指向当前实例所属类的原型")])])]),t._v(" "),a("h3",{attrs:{id:"_31-异步回调（如何解决回调地狱）"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_31-异步回调（如何解决回调地狱）","aria-hidden":"true"}},[t._v("#")]),t._v(" 31.异步回调（如何解决回调地狱）")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("promise、generator、async/await\n\npromise： 1.是一个对象，用来传递异步操作的信息。代表着某个未来才会知道结果的时间，并未这个事件提供统一的api，供进异步处理\n\t  2.有了这个对象，就可以让异步操作以同步的操作的流程来表达出来，避免层层嵌套的回调地狱\n\t  3.promise代表一个异步状态，有三个状态pending（进行中），Resolve(以完成），Reject（失败）\n\t  4.一旦状态改变，就不会在变。任何时候都可以得到结果。从进行中变为以完成或者失败\n\t\tpromise.all() 里面状态都改变，那就会输出，得到一个数组\n\t\tpromise.race() 里面只有一个状态变为rejected或者fulfilled即输出\n\t\tpromis.finally()不管指定不管Promise对象最后状态如何，都会执行的操作（本质上还是then方法的特例）\n复制代码\n")])])]),a("h3",{attrs:{id:"_32-前端事件流"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_32-前端事件流","aria-hidden":"true"}},[t._v("#")]),t._v(" 32.前端事件流")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("事件流描述的是从页面中接受事件的顺序，事件 捕获阶段 处于目标阶段 事件冒泡阶段 addeventListener 最后这个布尔值参数如果是true，表示在捕获阶段调用事件处理程序；如果是false，表示在冒泡阶段调用事件处理程序。\n  1、事件捕获阶段：实际目标div在捕获阶段不会接受事件，也就是在捕获阶段，事件从document到<html>再到<body>就停止了。\n      2、处于目标阶段：事件在div发生并处理，但是事件处理会被看成是冒泡阶段的一部分。\n      3、冒泡阶段：事件又传播回文档\n   阻止冒泡事件event.stopPropagation()\n\t  function stopBubble(e) {\n    \t\tif (e && e.stopPropagation) { // 如果提供了事件对象event 这说明不是IE浏览器\n      \t\te.stopPropagation()\n    \t\t} else {\n      \t\twindow.event.cancelBubble = true //IE方式阻止冒泡\n    \t      }\n  \t\t   }\n   阻止默认行为event.preventDefault()\n function stopDefault(e) {\n    if (e && e.preventDefault) {\n      e.preventDefault()\n    } else {\n      // IE浏览器阻止函数器默认动作的行为\n      window.event.returnValue = false\n    }\n  }\n复制代码\n")])])]),a("h3",{attrs:{id:"_33-事件如何先捕获后冒泡？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_33-事件如何先捕获后冒泡？","aria-hidden":"true"}},[t._v("#")]),t._v(" 33.事件如何先捕获后冒泡？")]),t._v(" "),a("blockquote",[a("p",[t._v("在 DOM 标准事件模型中，是先捕获后冒泡。但是如果要实现先冒泡后捕获的效果， 对于同一个事件，监听捕获和冒泡，分别对应相应的处理函数，监听到捕获事件，先暂缓执行，直到冒泡事件被捕获后再执行捕获事件。")])]),t._v(" "),a("ul",[a("li",[t._v("哪些事件不支持冒泡事件：鼠标事件：mouserleave mouseenter 焦点事件：blur focus UI 事件：scroll resize")])]),t._v(" "),a("h3",{attrs:{id:"_34-如何判断一个变量是对象还是数组（prototype-tostring-call-）。"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_34-如何判断一个变量是对象还是数组（prototype-tostring-call-）。","aria-hidden":"true"}},[t._v("#")]),t._v(" 34. 如何判断一个变量是对象还是数组（prototype.toString.call()）。")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("千万不要使用typeof来判断对象和数组，因为这种类型都会返回object。\n复制代码\n")])])]),a("blockquote",[a("p",[t._v("typeOf()是判断基本类型的 Boolean,Number，symbol, undefined, String。 对于引用类型：除 function，都返回 object null 返回 object。")])]),t._v(" "),a("blockquote",[a("p",[t._v("installOf() 用来判断 A 是否是 B 的实例，installof 检查的是原型。")])]),t._v(" "),a("blockquote",[a("p",[t._v("toString() 是 Object 的原型方法，对于 Object 对象，直接调用 toString() 就能返回 [Object Object] 。而对于其他对象，则需要通过 call / apply 来调用才能返回正确的类型信息。")])]),t._v(" "),a("blockquote",[a("p",[t._v("hasOwnProperty()方法返回一个布尔值，指示对象自身属性中是否具有指定的属性，该方法会忽略掉那些从原型链上继承到的属性。")])]),t._v(" "),a("blockquote",[a("p",[t._v("isProperty()方法测试一个对象是否存在另一个对象的原型链上。")])]),t._v(" "),a("h3",{attrs:{id:"_35-settimeout-和-setinterval-的机制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_35-settimeout-和-setinterval-的机制","aria-hidden":"true"}},[t._v("#")]),t._v(" 35.setTimeout 和 setInterval 的机制")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("因为js是单线程的。浏览器遇到etTimeout 和 setInterval会先执行完当前的代码块，在此之前会把定时器推入浏览器的\n待执行时间队列里面，等到浏览器执行完当前代码之后会看下事件队列里有没有任务，有的话才执行定时器里的代码\n复制代码\n")])])]),a("h3",{attrs:{id:"_36-splice-和-slice、map-和-foreach、-filter-、reduce-的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_36-splice-和-slice、map-和-foreach、-filter-、reduce-的区别","aria-hidden":"true"}},[t._v("#")]),t._v(" 36.splice 和 slice、map 和 forEach、 filter()、reduce()的区别")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v(" 1.slice(start,end):方法可以从已有数组中返回选定的元素，返回一个新数组，\n 包含从start到end（不包含该元素）的数组方法\n\t注意：该方法不会更新原数组，而是返回一个子数组\n 2.splice():该方法想或者从数组中添加或删除项目，返回被删除的项目。（该方法会改变原数组）\n\tsplice(index, howmany,item1,...itemx)\n\t\t·index参数：必须，整数规定添加或删除的位置，使用负数，从数组尾部规定位置\n\t\t·howmany参数：必须，要删除的数量，\n\t\t·item1..itemx:可选，向数组添加新项目\n3.map()：会返回一个全新的数组。使用于改变数据值的时候。会分配内存存储空间数组并返回，forEach（）不会返回数据\n4.forEach(): 不会返回任何有价值的东西，并且不打算改变数据，单纯的只是想用数据做一些事情，他允许callback更改原始数组的元素\n5.reduce(): 方法接收一个函数作为累加器，数组中的每一个值（从左到右）开始缩减，最终计算一个值，不会改变原数组的值\n6.filter(): 方法创建一个新数组，新数组中的元素是通过检查指定数组中符合条件的所有元素。它里面通过function去做处理\n复制代码\n")])])]),a("h2",{attrs:{id:"vue-问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vue-问题","aria-hidden":"true"}},[t._v("#")]),t._v(" VUE 问题")]),t._v(" "),a("h3",{attrs:{id:"_1-聊聊对-vue-的理解"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-聊聊对-vue-的理解","aria-hidden":"true"}},[t._v("#")]),t._v(" 1.聊聊对 vue 的理解")]),t._v(" "),a("blockquote",[a("p",[t._v("vue 是一个渐进式的 JS 框架。他易用，灵活，高效； 可以把一个页面分隔成多个组件；当其他页面有类似功能时，直接让封装的组件进行复用； 他是构建用户界面的声明式框架，只关心图层；不关心具体是如何实现的")])]),t._v(" "),a("h3",{attrs:{id:"_2-v-model-的原理是什么？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-v-model-的原理是什么？","aria-hidden":"true"}},[t._v("#")]),t._v(" 2.V-model 的原理是什么？")]),t._v(" "),a("blockquote",[a("p",[t._v("Vue 的双向数据绑定是由数据劫持结合发布者订阅者实现的。 数据劫持是通过 Object.defineProperty()来劫持对象数据的 setter 和 getter 操作。 在数据变动时作你想做的事")]),t._v(" "),a("ul",[a("li",[t._v("原理 通过 Observer 来监听自己的 model 数据变化，通过 Compile 来解析编译模板指令，最终利用 Watcher 搭起 Observer 和 Compile 之间的通信桥梁，达到数据变化->视图更新 在初始化 vue 实例时，遍历 data 这个对象，给每一个键值对利用 Object.definedProperty 对 data 的键值对新增 get 和 set 方法，利用了事件监听 DOM 的机制，让视图去改变数据")])])]),t._v(" "),a("h3",{attrs:{id:"_3-谈谈对生命周期的理解"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-谈谈对生命周期的理解","aria-hidden":"true"}},[t._v("#")]),t._v(" 3.谈谈对生命周期的理解")]),t._v(" "),a("ul",[a("li",[t._v("beforeCreate 阶段：vue 实例的挂载元素 el 和数据对象 data 都是 undefined，还没有初始化。")]),t._v(" "),a("li",[t._v("created 阶段：vue 实例的数据对象 data 有了，可以访问里面的数据和方法，未挂载到 DOM，el 还没有")]),t._v(" "),a("li",[t._v("beforeMount 阶段：vue 实例的 el 和 data 都初始化了，但是挂载之前为虚拟的 dom 节点")]),t._v(" "),a("li",[t._v("mounted 阶段：vue 实例挂载到真实 DOM 上，就可以通过 DOM 获取 DOM 节点")]),t._v(" "),a("li",[t._v("beforeUpdate 阶段：响应式数据更新时调用，发生在虚拟 DOM 打补丁之前，适合在更新之前访问现有的 DOM，比如手动移除已添加的事件监听器")]),t._v(" "),a("li",[t._v("updated 阶段：虚拟 DOM 重新渲染和打补丁之后调用，组成新的 DOM 已经更新，避免在这个钩子函数中操作数据，防止死循环")]),t._v(" "),a("li",[t._v("beforeDestroy 阶段：实例销毁前调用，实例还可以用，this 能获取到实例，常用于销毁定时器，解绑事件")]),t._v(" "),a("li",[t._v("destroyed 阶段：实例销毁后调用，调用后所有事件监听器会被移除，所有的子实例都会被销毁")])]),t._v(" "),a("h3",{attrs:{id:"_4-vue-和-react-有什么区别？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-vue-和-react-有什么区别？","aria-hidden":"true"}},[t._v("#")]),t._v(" 4.VUE 和 REACT 有什么区别？")]),t._v(" "),a("blockquote",[a("p",[t._v("react 整体是函数式的思想，把组件设计成纯组件，状态和逻辑通过参数传入，所以在 react 中，是单向数据流；")])]),t._v(" "),a("blockquote",[a("p",[t._v("vue 的思想是响应式的，也就是基于是数据可变的，通过对每一个属性建立 Watcher 来监听，当属性变化的时候，响应式的更新对应的虚拟 dom。")])]),t._v(" "),a("h3",{attrs:{id:"_5-vuex-的流程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-vuex-的流程","aria-hidden":"true"}},[t._v("#")]),t._v(" 5.vuex 的流程")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("页面通过mapAction异步提交事件到action。action通过commit把对应参数同步提交到mutation。\nmutation会修改state中对于的值。 最后通过getter把对应值跑出去，在页面的计算属性中\n通过mapGetter来动态获取state中的值\n复制代码\n")])])]),a("h3",{attrs:{id:"_6-vuex-有哪几种状态和属性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-vuex-有哪几种状态和属性","aria-hidden":"true"}},[t._v("#")]),t._v(" 6.vuex 有哪几种状态和属性")]),t._v(" "),a("blockquote",[a("ul",[a("li",[t._v("state 中保存着共有数据，数据是响应式的")]),t._v(" "),a("li",[t._v("getter 可以对 state 进行计算操作，主要用来过滤一些数据，可以在多组件之间复用")]),t._v(" "),a("li",[t._v("mutations 定义的方法动态修改 state 中的数据，通过 commit 提交方法，方法必须是同步的")]),t._v(" "),a("li",[t._v("actions 将 mutations 里面处理数据的方法变成异步的，就是异步操作数据，通 store.dispatch 来分发 actions，把异步的方法写在 actions 中，通过 commit 提交 mutations，进行修改数据。")]),t._v(" "),a("li",[t._v("modules：模块化 vuex")])])]),t._v(" "),a("h3",{attrs:{id:"_7-vue-路由的两种模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_7-vue-路由的两种模式","aria-hidden":"true"}},[t._v("#")]),t._v(" 7.vue 路由的两种模式")]),t._v(" "),a("blockquote",[a("ul",[a("li",[t._v("hash ——即地址栏 URL 中的#符号（此 hsah 不是密码学里的散列运算） hash 虽然出现 URL 中，但不会被包含在 HTTP 请求中，对后端完全没有影响，因此改变 hash 不会重新加载页面。")]),t._v(" "),a("li",[t._v("history ——利用了 HTML5 History Interface 中新增的 pushState() 和 replaceState() 方法")])]),t._v(" "),a("p",[t._v("这两个方法应用于浏览器的历史记录站，在当前已有的 back、forward、go 的基础之上，它们提供了对历史记录进行修改的功能。只是当它们执行修改是，虽然改变了当前的 URL，但你浏览器不会立即向后端发送请求。")])]),t._v(" "),a("h3",{attrs:{id:"_8-vue-中-key-值的作用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_8-vue-中-key-值的作用","aria-hidden":"true"}},[t._v("#")]),t._v(" 8.vue 中 key 值的作用")]),t._v(" "),a("blockquote",[a("p",[t._v("当 Vue.js 用 v-for 正在更新已渲染过的元素列表时，它默认用“就地复用”策略。 如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序，而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。")])]),t._v(" "),a("blockquote",[a("p",[t._v("key 的作用主要是为了高效的更新虚拟 DOM。")])]),t._v(" "),a("h3",{attrs:{id:"_9-route和-router的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_9-route和-router的区别","aria-hidden":"true"}},[t._v("#")]),t._v(" 9"),a("code",[t._v("$route")]),t._v("和"),a("code",[t._v("$router")]),t._v("的区别")]),t._v(" "),a("blockquote",[a("ul",[a("li",[t._v("$route 是“路由信息对象”，包括 path，params，hash，query，fullPath，matched，name 等路由信息参数。")]),t._v(" "),a("li",[t._v("$router 是“路由实例”对象包括了路由的跳转方法，钩子函数等。")])])]),t._v(" "),a("h3",{attrs:{id:"_10-vue-router-守卫"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_10-vue-router-守卫","aria-hidden":"true"}},[t._v("#")]),t._v(" 10.vue-router 守卫")]),t._v(" "),a("blockquote",[a("ul",[a("li",[t._v("导航守卫 router.beforeEach 全局前置守卫")])])]),t._v(" "),a("ul",[a("li",[t._v("to: Route: 即将要进入的目标（路由对象）")]),t._v(" "),a("li",[t._v("from: Route: 当前导航正要离开的路由")]),t._v(" "),a("li",[t._v("next: Function: 一定要调用该方法来 resolve 这个钩子。（一定要用这个函数才能去到下一个路由，如果不用就拦截） 执行效果依赖 next 方法的调用参数。")]),t._v(" "),a("li",[t._v("next(): 进行管道中的下一个钩子。如果全部钩子执行完了，则导航的状态就是 confirmed (确认的)。")]),t._v(" "),a("li",[t._v("next(false): 取消进入路由，url 地址重置为 from 路由地址(也就是将要离开的路由地址)。")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("// main.js 入口文件\n    import router from './router'; // 引入路由\n    router.beforeEach((to, from, next) => {\n      next();\n    });\n    router.beforeResolve((to, from, next) => {\n      next();\n    });\n    router.afterEach((to, from) => {\n      console.log('afterEach 全局后置钩子');\n    });\n\n复制代码\n")])])]),a("p",[t._v("路由独享的守卫 你可以在路由配置上直接定义 beforeEnter 守卫")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("const router = new VueRouter({\n  routes: [\n    {\n      path: '/foo',\n      component: Foo,\n      beforeEnter: (to, from, next) => {\n        // ...\n      }\n    }\n  ]\n})\n复制代码\n")])])]),a("p",[t._v("组件内的守卫 你可以在路由组件内直接定义以下路由导航守卫")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("const Foo = {\n  template: `...`,\n  beforeRouteEnter (to, from, next) {\n    // 在渲染该组件的对应路由被 confirm 前调用\n    // 不！能！获取组件实例 `this`\n    // 因为当守卫执行前，组件实例还没被创建\n  },\n  beforeRouteUpdate (to, from, next) {\n    // 在当前路由改变，但是该组件被复用时调用\n    // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，\n    // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。\n    // 可以访问组件实例 `this`\n  },\n  beforeRouteLeave (to, from, next) {\n    // 导航离开该组件的对应路由时调用，我们用它来禁止用户离开\n    // 可以访问组件实例 `this`\n    // 比如还未保存草稿，或者在用户离开前，\n    将setInterval销毁，防止离开之后，定时器还在调用。\n  }\n}\n复制代码\n")])])]),a("h3",{attrs:{id:"_11-axios-是什么？怎么使用？描述使用它实现登录功能的流程？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_11-axios-是什么？怎么使用？描述使用它实现登录功能的流程？","aria-hidden":"true"}},[t._v("#")]),t._v(" 11.axios 是什么？怎么使用？描述使用它实现登录功能的流程？")]),t._v(" "),a("blockquote",[a("p",[t._v("请求后台资源的模块。")])]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("$ npm install axios -S装好\n复制代码\n")])])]),a("blockquote",[a("p",[t._v("然后发送的是跨域，需在配置文件中 config/index.js 进行设置。后台如果是 Tp5 则定义一个资源路由。 js 中使用 import 进来，然后.get 或.post。返回在.then 函数中如果成功，失败则是在.catch 函数中")])]),t._v(" "),a("h3",{attrs:{id:"_12-vue-修饰符"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_12-vue-修饰符","aria-hidden":"true"}},[t._v("#")]),t._v(" 12.vue 修饰符")]),t._v(" "),a("ul",[a("li",[t._v("stop：阻止事件的冒泡")]),t._v(" "),a("li",[t._v("prevent：阻止事件的默认行为")]),t._v(" "),a("li",[t._v("once：只触发一次")]),t._v(" "),a("li",[t._v("self：只触发自己的事件行为时，才会执行")])]),t._v(" "),a("h3",{attrs:{id:"_13-vue-项目中的性能优化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_13-vue-项目中的性能优化","aria-hidden":"true"}},[t._v("#")]),t._v(" 13.vue 项目中的性能优化")]),t._v(" "),a("blockquote",[a("p",[t._v("1.不要在模板里面写过多表达式")])]),t._v(" "),a("blockquote",[a("p",[t._v("2.循环调用子组件时添加 key")])]),t._v(" "),a("blockquote",[a("p",[t._v("3.频繁切换的使用 v-show，不频繁切换的使用 v-if")])]),t._v(" "),a("blockquote",[a("p",[t._v("4.尽量少用 float，可以用 flex")])]),t._v(" "),a("blockquote",[a("p",[t._v("5.按需加载，可以用 require 或者 import()按需加载需要的组件")])]),t._v(" "),a("blockquote",[a("p",[t._v("6.路由懒加载")])]),t._v(" "),a("h3",{attrs:{id:"_14-vue-extend-和-vue-component"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_14-vue-extend-和-vue-component","aria-hidden":"true"}},[t._v("#")]),t._v(" 14.vue.extend 和 vue.component")]),t._v(" "),a("blockquote",[a("ul",[a("li",[t._v("extend 是构造一个组件的语法器。 然后这个组件你可以作用到 Vue.component 这个全局注册方法里 还可以在任意 vue 模板里使用组件。 也可以作用到 vue 实例或者某个组件中的 components 属性中并在内部使用 apple 组件。")]),t._v(" "),a("li",[t._v("Vue.component 你可以创建 ，也可以取组件。")])])]),t._v(" "),a("h4",{attrs:{id:"常见的兼容问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#常见的兼容问题","aria-hidden":"true"}},[t._v("#")]),t._v(" 常见的兼容问题")]),t._v(" "),a("blockquote",[a("p",[t._v("png24 位的图片在 iE6 浏览器上出现背景 解决方案是做成 PNG8.也可以引用一段脚本处理.")])]),t._v(" "),a("blockquote",[a("p",[t._v("浏览器默认的 margin 和 padding 不同。 解决方案是加一个全局的*{margin:0;padding:0;}来统一。")])]),t._v(" "),a("blockquote",[a("p",[t._v("IE6 双边距 bug:块属性标签 float 后，又有横行的 margin 情况下，在 ie6 显示 margin 比设置的大。")])]),t._v(" "),a("blockquote",[a("p",[t._v("浮动 ie 产生的双倍距离（IE6 双边距问题：在 IE6 下，如果对元素设置了浮动，同时又设置了 margin-left 或 margin-right，margin 值会加倍。） #box{ float:left; width:10px; margin:0 0 0 100px;}")])]),t._v(" "),a("h2",{attrs:{id:"react-问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react-问题","aria-hidden":"true"}},[t._v("#")]),t._v(" React 问题")]),t._v(" "),a("h3",{attrs:{id:"_1-react-和-vue-的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-react-和-vue-的区别","aria-hidden":"true"}},[t._v("#")]),t._v(" 1.react 和 vue 的区别")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("   =>  相同点：\n\t1.数据驱动页面，提供响应式的试图组件\n\t2.都有virtual DOM,组件化的开发，通过props参数进行父子之间组件传递数据，都实现了webComponents规范\n\t3.数据流动单向，都支持服务器的渲染SSR\n\t4.都有支持native的方法，react有React native， vue有wexx\n=>  不同点：\n\t1.数据绑定：Vue实现了双向的数据绑定，react数据流动是单向的\n\t2.数据渲染：大规模的数据渲染，react更快\n\t3.使用场景：React配合Redux架构适合大规模多人协作复杂项目，Vue适合小快的项目\n\t4.开发风格：react推荐做法jsx + inline style把html和css都写在js了\n\t\t    vue是采用webpack + vue-loader单文件组件格式，html, js, css同一个文件\n复制代码\n")])])]),a("h3",{attrs:{id:"_2-redux-中的-reducer（纯函数）"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-redux-中的-reducer（纯函数）","aria-hidden":"true"}},[t._v("#")]),t._v(" 2.redux 中的 reducer（纯函数）")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("Redux数据流里，reduces其实是根据之前的状态（previous state）和现有的action（current action）\n更新state(这个state可以理解为上下累加器的结果）\n每次redux reducer被执行时，state和action被传入，这个state根据action进行累加或者是'自身消减'(reduce),\n进而返回最新的state,这也就是典型reduce函数的用法：state ->  action ->  state\n复制代码\n")])])]),a("h3",{attrs:{id:"_3-react-的-refs"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-react-的-refs","aria-hidden":"true"}},[t._v("#")]),t._v(" 3.react 的 refs")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("refs就想一个逃生窗，允许我们之间访问dom元素或者组件实例，可以向组件添加一个ref属性的值是一个回调函数，\n它将接受地城dom元素或组件的已挂在实例，作为第一个参数\n复制代码\n")])])]),a("h3",{attrs:{id:"_4-react-中的-keys"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-react-中的-keys","aria-hidden":"true"}},[t._v("#")]),t._v(" 4.react 中的 keys")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("帮组我们跟踪哪些项目已更改、添加、从列表中删除，key是独一无二的，可以让我们高效的去定位元素，并且操作它\n复制代码\n")])])]),a("h3",{attrs:{id:"_5-react-的生命周期"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-react-的生命周期","aria-hidden":"true"}},[t._v("#")]),t._v(" 5.React 的生命周期")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("三个状态：Mounting(已插入真实的DOM）\n\t  Updating(正在被重新渲染)\n\t  Unmounting(已移除真实的DOM)\ncomponentDIdMount 在第一次渲染后调用，只在客服端。之后组件已经生成对应的DOM结构，\ncomponentDidUpdate 在组件完成更新后立即调用，在出初始化是不会调用\n复制代码\n")])])]),a("h3",{attrs:{id:"_6-react-子组件向父组件传值"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_6-react-子组件向父组件传值","aria-hidden":"true"}},[t._v("#")]),t._v(" 6.React 子组件向父组件传值")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("父组件通过props 给子组件传递数据，子组件则是通过调用父组件传给它的函数给父组件传递数据。\n复制代码\n")])])]),a("h3",{attrs:{id:"_7-为什么虚拟-dom-会提高性能-www-zhihu-com-question-29…"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_7-为什么虚拟-dom-会提高性能-www-zhihu-com-question-29…","aria-hidden":"true"}},[t._v("#")]),t._v(" 7.为什么虚拟 DOM 会提高性能 "),a("a",{attrs:{href:"https://www.zhihu.com/question/29504639?sort=created",target:"_blank",rel:"noopener noreferrer"}},[t._v("www.zhihu.com/question/29…"),a("OutboundLink")],1)]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("虚拟DOM相当于在js和真实dom中间加了一个缓存，利用dom diff算法避免了没有必要的doom操作，从而提高性能\n具体实现步骤：\n\t·用JavaScript对象结构表示DOM树的结构；然后用这个树构建一个真正的DOM树，插到文档中\n        ·当状态变更的时候，重新构造一棵树的对象树，然后用新的树和旧的树进行对比，记录两棵树差异\n\t·把2所记录的差异应用到步骤1所构建的真正的DOM树上，试图就更新了。\n复制代码\n")])])]),a("h3",{attrs:{id:"_8-diff-算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_8-diff-算法","aria-hidden":"true"}},[t._v("#")]),t._v(" 8.diff 算法")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("1.把树形结构按照层级分解，只比较同级元素\n2.给列表结构的每个单元添加key属性，方便比较。在实际代码中，会对新旧两棵树进行一个深度优先的遍历，这样每个节点都会有一个标记\n3.在深度优先遍历的时候，每遍历到一个节点就把该节点和新的树进行对比。如果有差异的话就记录到一个对象里面\nVritual DOM 算法主要实现上面步骤的三个函数：element， diff， patch。然后就可以实际的进行使用\nreact只会匹配相同的class的component（这里的class指的是组件的名字）\n合并操作，条用component的setState方法的时候，React将其标记为dirty.到每一个时间循环借宿，React检查所有标记dirty的component重新绘制\n4.选择性子树渲染。可以重写shouldComponentUpdate提高diff的性能\n复制代码\n")])])]),a("h3",{attrs:{id:"_9-简述下-flux-的思想"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_9-简述下-flux-的思想","aria-hidden":"true"}},[t._v("#")]),t._v(" 9.简述下 flux 的思想")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("flux的最大特点，就是数据的‘单向流动’\n1.用户访问View\n2.View发出用户的Action\n3.Dispatcher收到Action,要求state进行相应的更新\n4.store更新后，发出一个‘change’事件后，更新页面\n复制代码\n")])])]),a("h3",{attrs:{id:"_10-reac-性能优化是哪个周期函"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_10-reac-性能优化是哪个周期函","aria-hidden":"true"}},[t._v("#")]),t._v(" 10.reac 性能优化是哪个周期函")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("shouldComponentUpdate 这个方法用来判断是否需要调用render方法重新描绘dom.因为dom的描绘非常消耗性能，\n如果我们在shouldComponentUpdate方法中能够写出更优化的dom diff算法，可以极大的提高性能\n复制代码\n")])])]),a("h3",{attrs:{id:"_11-react-怎么划分业务组件和技术组件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_11-react-怎么划分业务组件和技术组件","aria-hidden":"true"}},[t._v("#")]),t._v(" 11.react 怎么划分业务组件和技术组件")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("根据组件的职责通常把组件分为UI组件和容器组件\nUI组件负责UI的呈现，容器组件负责管理数据和逻辑\n两者通过React-redux提供connect方法联系起来\n复制代码\n")])])]),a("h3",{attrs:{id:"_12-setstate"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_12-setstate","aria-hidden":"true"}},[t._v("#")]),t._v(" 12.setState")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("setState通过一个队列机制实现state更新，当执行setState时，会将需要更新的state很后放入状态队列\n而不会立即更新this.state，队列机制可以高效地批量更新state。如果不通过setState而直接修改this.state的值\n那么该state将不会被放入状态队列中。当下次调用setState并对状态队列进行合并时，就会忽略之前修改的state，造成不可预知的错误\n\n同时，也利用了队列机制实现了setState的异步更新，避免了频繁的重复更新state\n\n同步更新state:\n\tsetState 函数并不会阻塞等待状态更新完毕，因此 setNetworkActivityIndicatorVisible 有可能先于数据渲染完毕就执行。\n\t第二个参数是一个回调函数，在setState的异步操作结束并且组件已经重新渲染的时候执行\n\t也就是说，我们可以通过这个回调来拿到更新的state的值，实现代码的同步\n\n例子：componentDidMount() {\n\n\tfetch('https://test.com')\n\n\t.then((res) => res.json())\n\n\t.then(\n    (data) => {\nthis.setState({ data:data });\n\t\t\tStatusBar.setNetworkActivityIndicatorVisible(false);\n        }\n复制代码\n")])])]),a("h2",{attrs:{id:"性能优化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#性能优化","aria-hidden":"true"}},[t._v("#")]),t._v(" 性能优化")]),t._v(" "),a("h3",{attrs:{id:"一、webpack-打包文件体积过大？（最终打包为一个-js-文件）"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#一、webpack-打包文件体积过大？（最终打包为一个-js-文件）","aria-hidden":"true"}},[t._v("#")]),t._v(" 一、webpack 打包文件体积过大？（最终打包为一个 js 文件）")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("1.异步加载模块\n2.提取第三库\n3.代码压缩\n4.去除不必要的插件\n复制代码\n")])])]),a("h3",{attrs:{id:"二、如何优化-webpack-构建的性能"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#二、如何优化-webpack-构建的性能","aria-hidden":"true"}},[t._v("#")]),t._v(" 二、如何优化 webpack 构建的性能")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("一、减少代码体积 1.使用CommonsChunksPlugin 提取多个chunk之间的通用模块，减少总体代码体积\n\t\t 2.把部分依赖转移到CDN上，避免每次编译过程都由Webpack处理\n\t\t 3.对一些组件库采用按需加载，避免无用的代码\n二、减少目录检索范围\n\t\t ·在使用loader的时候，通过制定exclude和include选项，减少loader遍历的目录范围，从而加快webpack编译速度\n\n三、减少检索路经：resolve.alias可以配置webpack模块解析的别名，对于比较深的解析路经，可以对其配置alias\n复制代码\n")])])]),a("h3",{attrs:{id:"三、移动端的性能优化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#三、移动端的性能优化","aria-hidden":"true"}},[t._v("#")]),t._v(" 三、移动端的性能优化")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("  1、首屏加载和按需加载，懒加载\n  2、资源预加载\n  3、图片压缩处理，使用base64内嵌图片\n  4、合理缓存dom对象\n  5、使用touchstart代替click（click 300毫秒的延迟）\n  6、利用transform:translateZ(0)，开启硬件GUP加速\n  7、不滥用web字体，不滥用float（布局计算消耗性能），减少font-size声明\n  8、使用viewport固定屏幕渲染，加速页面渲染内容\n  9、尽量使用事件代理，避免直接事件绑定\n复制代码\n")])])]),a("h3",{attrs:{id:"四、vue-的-spa-如何优化加载速度"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#四、vue-的-spa-如何优化加载速度","aria-hidden":"true"}},[t._v("#")]),t._v(" 四、Vue 的 SPA 如何优化加载速度")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("1.减少入口文件体积\n2.静态资源本地缓存\n3.开启Gzip压缩\n4.使用SSR,nuxt.js\n复制代码\n")])])]),a("h3",{attrs:{id:"五、移动端-300ms-延迟"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#五、移动端-300ms-延迟","aria-hidden":"true"}},[t._v("#")]),t._v(" 五、移动端 300ms 延迟")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("由来：\n300毫米延迟解决的是双击缩放。双击缩放，手指在屏幕快速点击两次。safari浏览器就会将网页缩放值原始比例。由于用户可以双击缩放或者是滚动的操作，\n当用户点击屏幕一次之后，浏览器并不会判断用户确实要打开至这个链接，还是想要进行双击操作\n因此，safair浏览器就会等待300ms，用来判断用户是否在次点击了屏幕\n\n解决方案：1.禁用缩放，设置meta标签 user-scalable=no\n\t  2.fastclick.js\n\t\t原理：FastClick的实现原理是在检查到touchend事件的时候，会通过dom自定义事件立即\n\t\t      发出click事件，并把浏览器在300ms之后真正的click事件阻止掉\nfastclick.js还可以解决穿透问题\n复制代码\n")])])]),a("h3",{attrs:{id:"六、页面的重构；"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#六、页面的重构；","aria-hidden":"true"}},[t._v("#")]),t._v(" 六、页面的重构；")]),t._v(" "),a("blockquote",[a("p",[t._v("在不改变外部行为的前提下，简化结构、添加可读性")])]),t._v(" "),a("h2",{attrs:{id:"服务器端"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#服务器端","aria-hidden":"true"}},[t._v("#")]),t._v(" 服务器端")]),t._v(" "),a("h3",{attrs:{id:"一、状态码："}},[a("a",{staticClass:"header-anchor",attrs:{href:"#一、状态码：","aria-hidden":"true"}},[t._v("#")]),t._v(" 一、状态码：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("  2XX（成功处理了请求状态）\n      200 服务器已经成功处理请求，并提供了请求的网页\n      201 用户新建或修改数据成功\n      202 一个请求已经进入后台\n      204 用户删除成功\n  3XX（每次请求使用的重定向不要超过5次）\n      304 网页上次请求没有更新，节省带宽和开销\n  4XX（表示请求可能出错，妨碍了服务器的处理）\n      400 服务器不理解请求的语法\n      401 用户没有权限（用户名，密码输入错误）\n      403 用户得到授权（401相反），但是访问被禁止\n      404 服务器找不到请求的网页，\n  5XX（表示服务器在处理请求的时候发生内部错误）\n      500 服务器遇到错误，无法完成请求\n      503 服务器目前无法使用（超载或停机维护）\n复制代码\n")])])]),a("h3",{attrs:{id:"二、304-的缓存原理（添加-etag-标签-last-modified）-304-网页上次请求没有更新，节省带宽和开销"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#二、304-的缓存原理（添加-etag-标签-last-modified）-304-网页上次请求没有更新，节省带宽和开销","aria-hidden":"true"}},[t._v("#")]),t._v(" 二、304 的缓存原理（添加 Etag 标签.last-modified） 304 网页上次请求没有更新，节省带宽和开销")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("1.服务器首先产生Etag,服务器可在稍后使用它来判断页面是否被修改。本质上，客户端通过该记号传回服务器要求服务器验证（客户端）缓存）\n2.304是\tHTTP的状态码，服务器用来标识这个文件没有被修改，不返回内容，浏览器接受到这个状态码会去去找浏览器缓存的文件\n3.流程：客户端请求一个页面A。服务器返回页面A，并在A上加一个Tage客服端渲染该页面，并把Tage也存储在缓存中。客户端再次请求页面A\n\t并将上次请求的资源和ETage一起传递给服务器。服务器检查Tage.并且判断出该页面自上次客户端请求之后未被修改。直接返回304\n\nlast-modified: 客服端请求资源，同时有一个last-modified的属性标记此文件在服务器最后修改的时间\n\t\t客服端第二次请求此url时，根据http协议。浏览器会向服务器发送一个If-Modified-Since报头，\n\t\t询问该事件之后文件是否被修改，没修改返回304\n\n 有了Last-Modified，为什么还要用ETag？\n  1、因为如果在一秒钟之内对一个文件进行两次更改，Last-Modified就会不正确（Last—Modified不能识别秒单位的修改）\n  2、某些服务器不能精确的得到文件的最后修改时间\n  3、一些文件也行会周期新的更改，但是他的内容并不改变（仅仅改变修改的事件），这个时候我们并不希望客户端认为文件被修改，而重新Get\n\nETag，为什么还要用Last-Modified？\n  1、两者互补，ETag的判断的缺陷，比如一些图片等静态文件的修改\n  2、如果每次扫描内容都生成ETag比较，显然要比直接比较修改时间慢的多。\n\n\nETag是被请求变量的实体值（文件的索引节，大小和最后修改的时间的Hash值）\n  1、ETag的值服务器端对文件的索引节，大小和最后的修改的事件进行Hash后得到的。\n复制代码\n")])])]),a("h3",{attrs:{id:"三、get-post-的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#三、get-post-的区别","aria-hidden":"true"}},[t._v("#")]),t._v(" 三、get/post 的区别")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("1.get数据是存放在url之后，以？分割url和传输数据，参数之间以&相连； post方法是把提交的数据放在http包的Body中\n2.get提交的数据大小有限制，（因为浏览器对url的长度有限制），post的方法提交的数据没有限制\n3.get需要request.queryString来获取变量的值，而post方式通过request.from来获取变量的值\n4.get的方法提交数据，会带来安全问题，比如登录一个页面，通过get的方式提交数据，用户名和密码就会出现在url上\n复制代码\n")])])]),a("h3",{attrs:{id:"四、http-协议的理解"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#四、http-协议的理解","aria-hidden":"true"}},[t._v("#")]),t._v(" 四、http 协议的理解")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("1.超文本的传输协议，是用于从万维网服务器超文本传输到本地资源的传输协议\n2.基于TCP/IP通信协议来传递数据（HTML，图片资源）\n3.基于运用层的面向对象的协议，由于其简洁、快速的方法、适用于分布式超媒体信息系统\n4.http请求信息request：\n\t请求行（request line）、请求头部（header）,空行和请求数据四部分构成\n\n\t请求行，用来说明请求类型,要访问的资源以及所使用的HTTP版本.\n\t请求头部，用来说明服务器要使用的附加信息\n\t空行，请求头部后面的空行是必须的\n\t请求数据也叫主体，可以添加任意的其他数据。\n5.http相应信息Response\n\t状态行、消息报头、空行和响应正文\n\n\t状态行，由HTTP协议版本号， 状态码， 状态消息 三部分组成\n\t消息报头，用来说明客户端要使用的一些附加信息\n\t空行，消息报头后面的空行是必须的\n\t响应正文，服务器返回给客户端的文本信息。\n复制代码\n")])])]),a("h3",{attrs:{id:"五、http-和-https"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#五、http-和-https","aria-hidden":"true"}},[t._v("#")]),t._v(" 五、http 和 https")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("https：是以安全为目标的HTTP通道，简单讲是HTTP的安全版本，通过SSL加密\nhttp：超文本传输协议。是一个客服端和服务器端请求和应答的标准（tcp）,使浏览器更加高效，使网络传输减少\n复制代码\n")])])]),a("h3",{attrs:{id:"六、http1-0-1-1-2-0-的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#六、http1-0-1-1-2-0-的区别","aria-hidden":"true"}},[t._v("#")]),t._v(" 六、http1.0 1.1 2.0 的区别")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("长连接：HTTP1.0需要使用keep-alive参数来告知服务器建立一个长连接，而HTP1.1默认支持长连接\n节约宽带：HTTP1.1支持只发送一个header信息（不带任何body信息）\nhost域（设置虚拟站点，也就是说，web server上的多个虚拟站点可以共享同一个ip端口）：HTTP1.0没有host域\n\n1.http2采用的二进制文本传输数据，而非http1文本格式，二进制在协议的解析和扩展更好\n2.数据压缩：对信息头采用了HPACK进行压缩传输，节省了信息头带来的网络流量\n3.多路复用：一个连接可以并发处理多个请求\n4.服务器推送：我们对支持HTTP2.0的web server请求数据的时候，服务器会顺便把一些客户端需要的资源一起推送到客户端，免得客户端再次创建连接发送请求到服务器端获取。这种方式非常合适加载静态资源\n复制代码\n")])])]),a("h3",{attrs:{id:"七、web-缓存"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#七、web-缓存","aria-hidden":"true"}},[t._v("#")]),t._v(" 七、web 缓存")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("1.web缓存就是存在于客户端与服务器之间的一个副本、当你第一个发出请求后，缓存根据请求保存输出内容的副本\n2.缓存的好处\n        （1）减少不必要的请求\n    （2）降低服务器的压力，减少服务器的消耗\n    （3）降低网络延迟，加快页面打开速度（直接读取浏览器的数据）\n复制代码\n")])])]),a("h3",{attrs:{id:"八、常见的-web-安全及防护原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#八、常见的-web-安全及防护原理","aria-hidden":"true"}},[t._v("#")]),t._v(" 八、常见的 web 安全及防护原理")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("1.sql注入原理：是将sql代码伪装到输入参数中，传递到服务器解析并执行的一种攻击手法。也就是说，\n            在一些对server端发起的请求参数中植入一些sql代码，server端在执行sql操作时，会拼接对应参数，\n            同时也将一些sql注入攻击的“sql”拼接起来，导致会执行一些预期之外的操作。\n\t\t防范：1.对用户输入进行校验\n\t\t       2.不适用动态拼接sql\n2.XSS（跨站脚本攻击）：往web页面插入恶意的html标签或者js代码。\n\t\t        举例子：在论坛放置一个看是安全的链接，窃取cookie中的用户信息\n\t\t\t防范：1.尽量采用post而不使用get提交表单\n\t\t\t      2.避免cookie中泄漏用户的隐式\n3.CSRF(跨站请求伪装）：通过伪装来自受信任用户的请求\n\t\t\t举例子：黄轶老师的webapp音乐请求数据就是利用CSRF跨站请求伪装来获取QQ音乐的数据\n\t\t\t防范：在客服端页面增加伪随机数，通过验证码\nXSS和CSRF的区别：\n   1.XSS是获取信息，不需要提前知道其他用户页面的代码和数据包\n   2.CSRF代替用户完成指定的动作，需要知道其他页面的代码和数据包\n复制代码\n")])])]),a("h3",{attrs:{id:"九、cdn（内容分发网络）"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#九、cdn（内容分发网络）","aria-hidden":"true"}},[t._v("#")]),t._v(" 九、CDN（内容分发网络）")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("1.尽可能的避开互联网有可能影响数据传输速度和稳定性的瓶颈和环节。使内容传输的更快更稳定。\n2.关键技术：内容存储和分发技术中\n3.基本原理：广泛采用各种缓存服务器，将这些缓存服务器分布到用户访问相对的地区或者网络中。当用户访问网络时利用全局负载技术\n\t    将用户的访问指向距离最近的缓存服务器，由缓存服务器直接相应用户的请求（全局负载技术）\n复制代码\n")])])]),a("h3",{attrs:{id:"十、tcp-三次握手-客服端和服务器端都需要确认各自可收发）"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#十、tcp-三次握手-客服端和服务器端都需要确认各自可收发）","aria-hidden":"true"}},[t._v("#")]),t._v(" 十、TCP 三次握手 (客服端和服务器端都需要确认各自可收发）")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("客服端发c起请求连接服务器端s确认，服务器端也发起连接确认客服端确认。\n第一次握手：客服端发送一个请求连接，服务器端只能确认自己可以接受客服端发送的报文段\n第二次握手： 服务端向客服端发送一个链接，确认客服端收到自己发送的报文段\n第三次握手： 服务器端确认客服端收到了自己发送的报文段\n复制代码\n")])])]),a("h3",{attrs:{id:"十一、从输入-url-到获取页面的完整过程-blog-csdn-net-samjustin1-…"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#十一、从输入-url-到获取页面的完整过程-blog-csdn-net-samjustin1-…","aria-hidden":"true"}},[t._v("#")]),t._v(" 十一、从输入 url 到获取页面的完整过程 "),a("a",{attrs:{href:"https://blog.csdn.net/samjustin1/article/details/52650520",target:"_blank",rel:"noopener noreferrer"}},[t._v("blog.csdn.net/samjustin1/…"),a("OutboundLink")],1)]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("1.查询NDS(域名解析),获取域名对应的IP地址  查询浏览器缓存\n2.浏览器与服务器建立tcp链接（三次握手）\n3.浏览器向服务器发送http请求(请求和传输数据）\n4.服务器接受到这个请求后，根据路经参数，经过后端的一些处理生成html代码返回给浏览器\n5.浏览器拿到完整的html页面代码开始解析和渲染，如果遇到外部的css或者js，图片一样的步骤\n6.浏览器根据拿到的资源对页面进行渲染，把一个完整的页面呈现出来\n复制代码\n")])])]),a("h3",{attrs:{id:"十二、浏览器渲染原理及流程-dom-cssom-render-layout-print"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#十二、浏览器渲染原理及流程-dom-cssom-render-layout-print","aria-hidden":"true"}},[t._v("#")]),t._v(" 十二、浏览器渲染原理及流程 DOM -> CSSOM -> render -> layout -> print")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("流程：解析html以及构建dom树 -> 构建render树 ->  布局render树 -> 绘制render树\n概念：1.构建DOM树： 渲染引擎解析HTML文档，首先将标签转换成DOM树中的DOM node(包括js生成的标签)生成内容树\n      2.构建渲染树： 解析对应的css样式文件信息（包括js生成的样式和外部的css）\n      3.布局渲染树：从根节点递归调用，计算每一个元素的大小，位置等。给出每个节点所在的屏幕的精准位置\n      4.绘制渲染树：遍历渲染树，使用UI后端层来绘制每一个节点\n\n重绘：当盒子的位置、大小以及其他属性，例如颜色、字体大小等到确定下来之后，浏览器便把这些颜色都按照各自的特性绘制一遍，将内容呈现在页面上\n\t触发重绘的条件：改变元素外观属性。如：color，background-color等\n\t重绘是指一个元素外观的改变所触发的浏览器行为，浏览器会根据元素的新属性重新绘制，使元素呈现新的外观\n注意：table及其内部元素需要多次计算才能确定好其在渲染树中节点的属性值，比同等元素要多发时间，要尽量避免使用table布局\n\n重排（重构/回流/reflow）： 当渲染书中的一部分（或全部）因为元素的规模尺寸，布局，隐藏等改变而需要重新构建，这就是回流。\n\t每个页面都需要一次回流，就是页面第一次渲染的时候\n\n重排一定会影响重绘，但是重绘不一定会影响重排\n复制代码\n")])])]),a("h3",{attrs:{id:"十三、为什么-css-放在顶部而-js-写在后面"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#十三、为什么-css-放在顶部而-js-写在后面","aria-hidden":"true"}},[t._v("#")]),t._v(" 十三、为什么 css 放在顶部而 js 写在后面")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("1.浏览器预先加载css后，可以不必等待HTML加载完毕就可以渲染页面了\n2.其实HTML渲染并不会等到完全加载完在渲染页面，而是一边解析DOM一边渲染。\n3.js写在尾部，主要是因为js主要扮演事件处理的功能，一方面很多操作是在页面渲染后才执行的。另一方面可以节省加载时间，使页面能够更加的加载，提高用户的良好体验\n\n但是随着JS技术的发展，JS也开始承担页面渲染的工作。比如我们的UI其实可以分被对待，把渲染页面的js放在前面，时间处理的js放在后面\n复制代码\n")])])]),a("h3",{attrs:{id:"十四、存储方式与传输方式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#十四、存储方式与传输方式","aria-hidden":"true"}},[t._v("#")]),t._v(" 十四、存储方式与传输方式")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("1.indexBD: 是h5的本地存储库，把一些数据存储到浏览器中，没网络，浏览器可以从这里读取数据，离线运用。5m\n2.Cookie: 通过浏览器记录信息确认用户身份，最大4kb,这也就限制了传输的数据，请求的性能会受到影响\n3.Session: 服务器端使用的一种记录客户状态的机制（session_id存在set_cookie发送到客服端，保存为cookie）\n4.localStroage: h5的本地存储，数据永久保存在客服端\n复制代码\n")])])]),a("h3",{attrs:{id:"cookie，sessionstorage，localstorage"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#cookie，sessionstorage，localstorage","aria-hidden":"true"}},[t._v("#")]),t._v(" cookie，sessionStorage，localStorage")]),t._v(" "),a("p",[t._v("1、cookie，sessionStorage，localStorage 是存放在客户端，session 对象数据是存放在服务器上 实际上浏览器和服务器之间仅需传递 session id 即可，服务器根据 session-id 找到对应的用户 session 对象 session 存储数据更安全一些，一般存放用户信息，浏览器只适合存储一般的数据 2、cookie 数据始终在同源的 http 请求中携带，在浏览器和服务器来回传递，里面存放着 session-id sessionStorage，localStorage 仅在本地保存 3、大小限制区别，cookie 数据不超过 4kb，localStorage 在谷歌浏览中 2.6MB 4、数据有效期不同，cookie 在设置的（服务器设置）有效期内有效，不管窗口和浏览器关闭 sessionStorage 仅在当前浏览器窗口关闭前有效，关闭即销毁（临时存储） localStorage 始终有效")]),t._v(" "),a("p",[t._v("SessionStorage 和 localStorage 区别： 1.sessionStorage 用于本地存储一个会话（session）中的数据，这些数据只有在用一个会话的页面中才能被访问（也就是说在第一次通信过程中） 并且在会话结束后数据也随之销毁，不是一个持久的本地存储，会话级别的储存 2.localStorage 用于持久化的本地存储，除非主动删除数据，否则不会过期")]),t._v(" "),a("h3",{attrs:{id:"token、cookie、session-三者的理解？？？！！！"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#token、cookie、session-三者的理解？？？！！！","aria-hidden":"true"}},[t._v("#")]),t._v(" token、cookie、session 三者的理解？？？！！！")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("1、token就是令牌，比如你授权(登录)一个程序时,他就是个依据,判断你是否已经授权该软件（最好的身份认证，安全性好，且是唯一的）\n    用户身份的验证方式\n\n2、cookie是写在客户端一个txt文件，里面包括登录信息之类的，这样你下次在登录某个网站，就会自动调用cookie自动登录用户名\n    服务器生成，发送到浏览器、浏览器保存，下次请求再次发送给服务器（存放着登录信息）\n\n3、session是一类用来客户端和服务器之间保存状态的解决方案，会话完成被销毁（代表的就是服务器和客户端的一次会话过程）\n    cookie中存放着sessionID，请求会发送这个id。sesion因为request对象而产生。\n复制代码\n")])])]),a("h3",{attrs:{id:"基于-token-的身份验证：（最简单的-token-uid-用户唯一的身份识别-time-当前事件戳-sign-签名）"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#基于-token-的身份验证：（最简单的-token-uid-用户唯一的身份识别-time-当前事件戳-sign-签名）","aria-hidden":"true"}},[t._v("#")]),t._v(" 基于 Token 的身份验证：（最简单的 token: uid 用户唯一的身份识别 + time 当前事件戳 + sign 签名）")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("  1、用户通过用户名和密码发送请求\n  2、服务器端验证\n  3、服务器端返回一个带签名的token，给客户端\n  4、客户端储存token，并且每次用于发送请求\n  5、服务器验证token并且返回数据\n  每一次请求都需要token\n复制代码\n")])])]),a("h3",{attrs:{id:"cookie-与-session-区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#cookie-与-session-区别","aria-hidden":"true"}},[t._v("#")]),t._v(" cookie 与 session 区别")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("  1、cookie数据存放在客户的浏览器上，session数据放在服务器上。\n  2、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗考虑到安全应当使用session。\n  3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能考虑到减轻服务器性能方面，应当使用COOKIE。\n  4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。\n复制代码\n")])])]),a("h3",{attrs:{id:"session-与-token-区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#session-与-token-区别","aria-hidden":"true"}},[t._v("#")]),t._v(" session 与 token 区别")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("  1、session认证只是把简单的User的信息存储Session里面，sessionID不可预测，一种认证手段。只存在服务端，不能共享到其他的网站和第三方App\n  2、token是oAuth Token，提供的是认证和授权，认证针对用户，授权是针对App，目的就是让某APP有权访问某用户的的信息。Token是唯一的，\n     token不能转移到其他的App，也不能转到其他用户上。（适用于App）\n  3、session的状态是存在服务器端的，客户端只存在session id， Token状态是存储在客户端的\n复制代码\n")])])]),a("h3",{attrs:{id:"cookie-的弊端有哪些？？？（优势：保存客户端数据，分担了服务器存储的负担）"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#cookie-的弊端有哪些？？？（优势：保存客户端数据，分担了服务器存储的负担）","aria-hidden":"true"}},[t._v("#")]),t._v(" Cookie 的弊端有哪些？？？（优势：保存客户端数据，分担了服务器存储的负担）")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("  1、数量和长度的限制。每个特定的域名下最多生成20个cookie（chorme和safari没有限制）\n  2、安全性问题。\n复制代码\n")])])]),a("h2",{attrs:{id:"设计模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#设计模式","aria-hidden":"true"}},[t._v("#")]),t._v(" 设计模式")]),t._v(" "),a("blockquote",[a("p",[t._v("一、观察者模式："),a("a",{attrs:{href:"https://juejin.im/post/5a14e9edf265da4312808d86",target:"_blank",rel:"noopener noreferrer"}},[t._v("juejin.im/post/5a14e9…"),a("OutboundLink")],1),t._v(" "),a("a",{attrs:{href:"https://juejin.im/post/5af05d406fb9a07a9e4d2799",target:"_blank",rel:"noopener noreferrer"}},[t._v("juejin.im/post/5af05d…"),a("OutboundLink")],1),t._v(" 在软件开发设计中是一个对象(subject)，维护一系列依赖他的对象（observer），当任何状态发生改变自动通知他们。强依赖关系 简单理解：数据发生改变时，对应的处理函数就会自动执行。一个 Subjet,用来维护 Observers,为某些 event 来通知（notify）观察者")])]),t._v(" "),a("blockquote",[a("p",[t._v("二、发布-订阅者 有一个信息中介，过滤 耦合性低 它定义了一种一对多的关系，可以使多个观察者对象对一个主题对象进行监听，当这个主题对象发生改变时，依赖的所有对象都会被通知到。")])]),t._v(" "),a("ul",[a("li",[t._v("-两者的区别： 1.观察者模式中，观察者知道 Subject ,两者是相关联的，而发发布订阅者只有通过信息代理进行通信 2.在发布订阅模式中，组件式松散耦合的。正好和观察者模式相反。 3.观察者大部分是同步的，比如事件的触发。Subject 就会调用观察者的方法。而发布订阅者大多数是异步的（） 4.观察者模式需要在单个应用程序地址空间中实现，而发布订阅者更像交叉应用模式。")])]),t._v(" "),a("h2",{attrs:{id:"数据结构和算法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#数据结构和算法","aria-hidden":"true"}},[t._v("#")]),t._v(" 数据结构和算法")]),t._v(" "),a("h3",{attrs:{id:"一、两个栈实现一个队列，两个队列实现一个栈-www-cnblogs-com-mrlistening…"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#一、两个栈实现一个队列，两个队列实现一个栈-www-cnblogs-com-mrlistening…","aria-hidden":"true"}},[t._v("#")]),t._v(" 一、两个栈实现一个队列，两个队列实现一个栈 "),a("a",{attrs:{href:"https://www.cnblogs.com/MrListening/p/5697459.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("www.cnblogs.com/MrListening…"),a("OutboundLink")],1)]),t._v(" "),a("h3",{attrs:{id:"二、红黑树（解决二叉树依次插入多个节点时的线型排列）-juejin-im-post-5a27c6…"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#二、红黑树（解决二叉树依次插入多个节点时的线型排列）-juejin-im-post-5a27c6…","aria-hidden":"true"}},[t._v("#")]),t._v(" 二、红黑树（解决二叉树依次插入多个节点时的线型排列） "),a("a",{attrs:{href:"https://juejin.im/post/5a27c6946fb9a04509096248",target:"_blank",rel:"noopener noreferrer"}},[t._v("juejin.im/post/5a27c6…"),a("OutboundLink")],1)]),t._v(" "),a("h3",{attrs:{id:"三、最小栈的实现（查找最小元素，用两个栈配合栈内元素的下标）juejin-im-post-5a2ff8…"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#三、最小栈的实现（查找最小元素，用两个栈配合栈内元素的下标）juejin-im-post-5a2ff8…","aria-hidden":"true"}},[t._v("#")]),t._v(" 三、最小栈的实现（查找最小元素，用两个栈配合栈内元素的下标）"),a("a",{attrs:{href:"https://juejin.im/post/5a2ff8c651882533d0230a85",target:"_blank",rel:"noopener noreferrer"}},[t._v("juejin.im/post/5a2ff8…"),a("OutboundLink")],1)]),t._v(" "),a("h3",{attrs:{id:"四、十大排序"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#四、十大排序","aria-hidden":"true"}},[t._v("#")]),t._v(" 四、十大排序")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("1.冒泡排序：重复走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把它们交换过来。\n  实现过程：1.比较相邻的元素。如果第一个比第二个大，就交换他们两个\n\t    2.对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数\n\t    3.针对所有的元素重复以上的步骤，除了最后一个\n\t    4.重复步骤1-3，直到排序完成。\n2.选择排序：首先在未排序序列中找到最小值，放在排序序列的起始位置，然后，在从剩下未排序元素中继续寻找最小值，然后放在与排序序列的末尾\n  实现过程：\n\n3.插入排序：构建有序序列，对于未排序数据，在已排序序列中冲后向前扫描，找到相应位置并插入\n  实现过程：1.从第一个元素开始，该元素可以认为已经被排序\n\t    2.取出下一个元素，在已排序的元素序列中冲后向前扫描\n\t    3.如果该元素（以排序）大于新元素，将元素向后移一位\n\t    4.在取出一个元素，比较之前的，直到找到自己合适的位置\n\n4.桶排序：将数据分布到有限数量的桶里，每个桶在分别排序\n\n1.快速排序：快速排序使用分治法把一个串（list）分为两个子串（sub-lists）.具体算法实现\n  实现过程：1.从数组中挑出一个元素，成为一个基准\n\t    2.重新排列数组，所有元素比基准小的摆在基准前面，所有元素比基准大的摆在基准后面（相同的可以摆在一边）\n\t\t这个分区退出之后，该基准就处于数列的中间位置。成为分区操作。\n\t    3.递归的把小于基准值的子数列和大于基准值元素的子数列排序\n算法实现： function quickSort (arr) {\n\t\tif （arr.length <= 1） {return arr}\n\t\tvar destIndex = Math.floor(arr.length/2)\n\t\tvar left = [], right = [];\n\t\tvar dest = arr.splice(destIndex,1)[0];\n\t\tfor (var i =0;i<arr.length;i++){\n\t\t\tif (arr[i]<dest) {\n\t\t\tleft.push(arr[i])\n\t\t\t} else {\n\t\t\tright.push(arr[i]) }\n\t\treturn quickSort(left).concat([dest],quickSort(right)\n\n\n2.堆排序：利用对这种数据结构所涉及的一种排序算法，堆积是一个近乎完全二叉树的结构，并同时满足堆积的性质：即子节点的键值或索引总是小于（或大于）它的父节点。\n  实现过程：1.\n复制代码\n")])])]),a("h3",{attrs:{id:"五、数组去重-juejin-im-post-5aed61…"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#五、数组去重-juejin-im-post-5aed61…","aria-hidden":"true"}},[t._v("#")]),t._v(" 五、数组去重 "),a("a",{attrs:{href:"https://juejin.im/post/5aed6110518825671b026bed#heading-6",target:"_blank",rel:"noopener noreferrer"}},[t._v("juejin.im/post/5aed61…"),a("OutboundLink")],1)]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("1.双重循环\n2.indexOf\n3.数组排序去重 最快你Olong\n复制代码\n")])])]),a("h3",{attrs:{id:"六、字符串"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#六、字符串","aria-hidden":"true"}},[t._v("#")]),t._v(" 六、字符串")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("判断回文字符串：（递归的思想）\n\t1.字符串分隔，倒转，聚合[...obj].reverse().join('')\n\t2.字符串头部和尾部，逐次向中间检测\n\t\t实现：function isPalindrome(line) {\n\t\t\tline += '';\n\t\t\tfor (var i=0,j=line.length-1;i<j;i++,j--) {\n\t\t\t\tif (line.chartAt(i) !== line.chartAt(j) {\n\t\t\t\treturn false\n\t\t\t}\n\n\t3.递归\n复制代码\n")])])]),a("h3",{attrs:{id:"七、二分查找（有序数组的查找）"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#七、二分查找（有序数组的查找）","aria-hidden":"true"}},[t._v("#")]),t._v(" 七、二分查找（有序数组的查找）")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v(" 二分查找可以解决已排序数组的查找问题，即只要数组中包含T(要查找的值)，那么通过不断的缩小包含T的数据范围，就可以最终要找到的数\n (1) 一开始,数据范围覆盖整个数组。\n (2) 将数组的中间项与T进行比较，如果T比数组的中间项小，则到数组的前半部分继续查找，反之，则到数组的后半部分继续查找。\n (3) 就这样，每次查找都可以排除一半元素，相当于范围缩小一半。这样反复比较，反复缩小范围，最终会在数组中找到T\n代码实现：function binarySearch (data, dest, start, end){\n\t\tvar end = end || data.length-1;\n\t\tvar start = start || 0;\n\t\tvar m = Math.floor((start+end)/2);\n\t\tif (dest<data[m]){\n\t\t\treturn binarySearch(data, dest, 0, m-1)\n\t\t} else {\n\t\t\treturn binarySearch(data, dest, m+1, end)\n\t\t}}\n\t\treturn false\n复制代码\n")])])]),a("h2",{attrs:{id:"手写代码"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#手写代码","aria-hidden":"true"}},[t._v("#")]),t._v(" 手写代码")]),t._v(" "),a("h3",{attrs:{id:"一、动手实现一个-bind（原理通过-apply，call）"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#一、动手实现一个-bind（原理通过-apply，call）","aria-hidden":"true"}},[t._v("#")]),t._v(" 一、动手实现一个 bind（原理通过 apply，call）")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("一句话概括：1.bind()返回一个新函数，并不会立即执行。\n\t    2.bind的第一个参数将作为他运行时的this，之后的一系列参数将会在传递的实参前传入作为他的参数\n\t    3.bind返回函数作为构造函数，就是可以new的，bind时指定的this值就会消失，但传入的参数依然生效\n复制代码\nFunction.prototype.bind = function (obj, arg) {\n   var arg = Array.prototype.slice.call(arguments, 1);\n   var context = this;\n   var bound = function (newArg) {\n   arg = arg.concat(Array.prototype.slice.call(newArg);\n   return context.apply(obj, arg)\n}\n  var F =  function () {}  // 在new一个bind会生成新函数，必须的条件就是要继承原函数的原型，因此用到寄生继承来完成我们的过程\n  F.prototype = context.prototype;\n  bound.prototype =  new F();\n  return bound;\n}\n复制代码\n")])])]),a("h3",{attrs:{id:"二、-ajax-（异步的-javascript-和-xml）"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#二、-ajax-（异步的-javascript-和-xml）","aria-hidden":"true"}},[t._v("#")]),t._v(" 二、 AJAX （异步的 javascript 和 xml）")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("ajax的原理：相当于在用户和服务器之间加一个中间层（ajax引擎),使用户操作与服务器响应异步化。\n优点：在不刷新整个页面的前提下与服务器通信维护数据。不会导致页面的重载\n      可以把前端服务器的任务转嫁到客服端来处理，减轻服务器负担，节省宽带\n劣势：不支持back。对搜索引擎的支持比较弱；不容易调试\n怎么解决呢？通过location.hash值来解决Ajax过程中导致的浏览器前进后退按键失效，\n解决以前被人常遇到的重复加载的问题。主要比较前后的hash值，看其是否相等，在判断是否触发ajax\n复制代码\nfunction getData(url) {\n    var xhr = new XMLHttpRequest();  // 创建一个对象，创建一个异步调用的对象\n    xhr.open('get', url, true)  // 设置一个http请求，设置请求的方式，url以及验证身份\n    xhr.send() //发送一个http请求\n    xhr.onreadystatechange = function () {  //设置一个http请求状态的函数\n      if (xhr.readyState == 4 && xhr.status ==200) {\n        console.log(xhr.responseText)  // 获取异步调用返回的数据\n      }\n    }\n  }\n  Promise(getData(url)).resolve(data => data)\n\n\t AJAX状态码：0 - （未初始化）还没有调用send()方法\n\t\t     1 - （载入）已调用send方法，正在发送请求\n\t\t     2 - （载入完成呢）send()方法执行完成\n\t\t     3 - （交互）正在解析相应内容\n\t\t     4 - （完成）响应内容解析完成，可以在客户端调用了\n")])])]),a("h3",{attrs:{id:"三、函数节流（throttle）"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#三、函数节流（throttle）","aria-hidden":"true"}},[t._v("#")]),t._v(" 三、函数节流（throttle）")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v(" function throttle (func, wait) {\n        var timeout;\n        var previous = 0;\n        return function () {\n            context = this;\n            args = arguments;\n            if (!timeout) {\n                timeout = setTimeout(() => {\n                    timeout = null;\n                    func.apply(context,args)\n                }, wait);\n            }\n        }\n    }\n\n}\n")])])]),a("h3",{attrs:{id:"四、函数防抖（dobounce）"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#四、函数防抖（dobounce）","aria-hidden":"true"}},[t._v("#")]),t._v(" 四、函数防抖（dobounce）")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v(" function debounce (func, wait) {\n         var timeout;\n         return function() {\n             var context = this;\n             var args = arguments;\n             clearTimeout(timeout);\n             timeout = setTimeout(() => {\n                 func.apply(context,args)\n             }, wait);\n         }\n     }\n")])])]),a("h3",{attrs:{id:"五、实现一个函数-clone，可以对-javascript-中的-5-种主要的数据类型（包括-number、string、object、array、boolean）进行值复制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#五、实现一个函数-clone，可以对-javascript-中的-5-种主要的数据类型（包括-number、string、object、array、boolean）进行值复制","aria-hidden":"true"}},[t._v("#")]),t._v(" 五、实现一个函数 clone，可以对 JavaScript 中的 5 种主要的数据类型（包括 Number、String、Object、Array、Boolean）进行值复制")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("    Object.prototype.clone = function() {\n      var newObject = this.constructor === Array ? [] : {}  //对象的深拷贝 获取对应的构造函数 [] 或者 {}\n      for (let e in this) { //遍历对象的属性 in  this[e]\n        newObject[e] = typeof this[e] === 'object' ? this[e].clone() : this[e]  //对象中的属性如果还是对象 那就继续递归 否则就返回基本的数据类型\n      }\n      return newObject\n    }\n")])])]),a("h3",{attrs:{id:"六、实现一个简单的-promise-https-juejin-im-post-5b2f02cd5188252b937548ab"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#六、实现一个简单的-promise-https-juejin-im-post-5b2f02cd5188252b937548ab","aria-hidden":"true"}},[t._v("#")]),t._v(" 六、实现一个简单的 Promise https://juejin.im/post/5b2f02cd5188252b937548ab")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("class Promise {\n  constructor (executor) {   // executor里面有两个参数，一个叫resolve（成功），一个叫reject（失败）。\n    this.status = 'pending',\n    this.value = undefined;\n    this.reason = undefined;\n    // 成功存放的数组\n    this.onResolvedCallbacks = [];\n     // 失败存放法数组\n     this.onRejectedCallbacks = [];\n    let resolve = (value) => {\n      if (this.status == 'pending') {\n        this.status = 'resolve';\n        this.value = value;\n        this.onResolvedCallbacks.forEach(fn => fn())\n      }\n    }\n\n    let reject = (reason) => {\n      if (this.status == 'pending') {\n        this.status = 'reject';\n        this.reason = reason;\n        this.onRejectedCallbacks.forEach(fn => fn())\n      }\n    }\n    try{\n      executor(resolve, reject);\n    } catch (err) {\n      reject(err);\n    }\n  }\n  then (onFullFilled,onRejected) {\n    if (this.status == 'resolved') {\n      onFullFilled(this.value)\n    }\n    if (this.status == 'rejectd') {\n      onRejected(this.reason);\n    }\n    if (this.status == 'pending') {\n      this.onResolvedCallbacks.push(()=>{\n        onFullFilled(this.value);\n      })\n      this.onRejectedCallbacks.push(()=> {\n          onRejected(this.reason);\n      })\n  }\n\n  }\n}\n\nconst p = new Promise((resolve, reject) => {\n  setTimeout(() => {\n      resolve('hello world')\n  }, 1000);\n})\np.then((data) =>{\n  console.log(data)\n},(err) =>{\n  console.log(err);\n})\n")])])]),a("h3",{attrs:{id:"七、发布订阅者模式（观察者模式）"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#七、发布订阅者模式（观察者模式）","aria-hidden":"true"}},[t._v("#")]),t._v(" 七、发布订阅者模式（观察者模式）")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("var event = {}; // 发布者\nevent.clientList = [] //发布者的缓存列表\n\nevent.listen = function (fn) {  // 增加订阅者函数\n  this.clientList.push(fn)\n}\n\nevent.trigger = function () {  // 发布信息\n  for (var i =0;i<this.clientList.length;i++) {\n    var fn = this.clientList[i];\n    fn.apply(this, arguments);\n  }\n}\n\nevent.listen (function(time) {\n  console.log('正式上班时间为：' +time)\n})\nevent.trigger ('2018/7')\n")])])]),a("h3",{attrs:{id:"八、手动写一个-node-服务器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#八、手动写一个-node-服务器","aria-hidden":"true"}},[t._v("#")]),t._v(" 八、手动写一个 node 服务器")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[t._v("const http = require('http');\nconst fs = require('fs');\nconst server = http.createServer((req,res) => {\n\tif (reu.url == '/') {\n\tconst indexFile = fs.createReadStream('./index.html')\n\treq.writeHead(200,{'context-Type':'text/html;charset = utf8})\n\tindexFile.pipe(res)\n}\nserver.listen(8080)\n")])])])])},[],!1,null,null,null);e.default=r.exports}}]);